# 在不变世界中的模式 #
Clojure提倡尽可能地消除程序中的状态。通常情况下，数据应该按照纯functional的方式来输入到函数和从函数中返回。这种方式使得things保持清晰、受保护和可并发。
但是，并不是所有情况都能达到这个目的。因为现实世界总是充满了各种变化的概念，所以真正的程序总是装满了状态。例如，如果你正在编写一个文字处理程序，那么程序中的当前被编辑的文档就有一个状态。如果你正在编写一个游戏程序，那么游戏世界的各种对象都有自己的状态。如果你在编写一个金融软件，那么账号中的金额数就是一个状态。这些都是现实世界所具备的实际情况，并且也是人所习惯的思考方式，所以我们的程序必须能够有效地对这些有状态的东西进行建模。
在并发环境中，有效地对状态进行建模虽然不是一件容易的事情，but absolutely necessary to get anything done。甚至除了并发问题外，如果一门语言能够有清晰的状态管理概念，那么它将具备很多优势。在单线程程序中，显式的状态惯例总比涂鸦式的、随处在应用程序中出现的状态惯例要好的多。Clojure提供了有效的显式状态管理。

## 旧的方式（The Old Way） ##
大多数编程语言通过相当朴素的处理方式来对状态建模，通常使用可修改的变量或对象的方式来表示状态。但是对这些变量和对象如何变化却没有明确的定义。通常程序采用“bash objects in place”的方式-每行代码在执行时能够自由地访问和修改任何东西。唯一能够保证一致性和避免并发修改bug的方式是在被访问的“东西”设置一些保护措施。这些保护措施通常被称为锁。

锁造成的问题是它们很难被正确地使用。为了能够正确使用它们，第一反应是更多地使用它们，这又造成了另一个问题：大范围地使用锁是可一个解决并发所产生的问题，但同时也降低了level of concurrency that is actually posible。不论一个程序创建了多少个线程，但它们碰到锁的话，也许只有一个线程能实际运行，而其它线程都在处于等待锁的控制权被释放。

所以，如果一直认为只存在易变的，可修改的“东西”，并且没有良好定义的规定来规范“东西”如何被修改的语义的话，锁只能是唯一的选择。对于一个更为有效的状态管理方法来说，重新评估、寻找更好的“things”的定义和建立”things“如何变化的清晰的规则。

## 状态和标识（State and Identity） ##
Clojure对待”things“的方式与其它程序语言在概念上有实质的改变，这些改变是经过深思熟虑的。Clojure采用了标准的”thing“的概念，即也称为对象或变量，同时将”thing“一分为二：状态和标识。每个“thing”都包含一个状态和一个标识。状态是标识在某一时刻所关联的一个值。标识是“thing”所不能变化的部分，它与不同时刻下的多个状态之间保持联系。每个状态的值是不变的，而且不可被修改。如果一个标识所指向的“thing”要被修改，那么就将当前状态整个替换为另一个状态。

举个例子，在1990年时，我还是一个小孩子，而在2010年，我已经是一个男人了，以此类推，在2050年我可能已经变为一个老头子。我分别用Luke1990、Luke2010、Luke2050来表示他们。虽然这三个Luke是非常不同的人，但他们都有一个共通的标识-都是我，Luke VanderHart。

在Clojure的术语中，Luke1990，Luke2010，Luke2050都是不同的值-不同的状态。我的名字，Luke VanderHart，是联系它们的标识。与Clojure的值类似，它们都是不变的。我可以为自己在不同的年份设定不同的Lukex，但是Luke1990是固化的，我不能对它做任何改变。当前，标识Luke VanderHart使用Luke2010作为它的状态，到明年它就有个新状态：Luke2011。Luke2011与Luke2010虽然相似，但也有很多隐含的差异。事实上在Clojure的模型中，每次我发生了变化，它都会产生新的状态：每当我有新的想法、感觉和情感时，都会产生与我的标识关联的新值。我本身就是由多个独特的，不可修改的人组成的，这些人之间有些许差异，但都由同一个标识联系起来。

再举个经常被程序实现的例子：我的银行账户。当我花钱和收钱时，我的银行账户的账面都会发生改变。很明显，这需要作为一个可变的状态。在这个例子中，“我的账户”是不变的-也即是账户结余标识。那么这里的状态就是特定时刻下账户中的金额数。例如，原来有$1000刀，如果我收到一张$100刀的支票，那么这时账户结余标识就更新为指向一个新的状态-$1100刀。请注意我并没有修改状态的值，因为将整数1000改为1100是明显不可能的，因为1000和1100是不同的数值。状态自身并没有被改变，而是账户结余标识现在指向了一个新的状态。这个更新是原子性的（atomically），不可分割的，因为账户结余的值并没有中间状态。在程序的任何地方都能安全地获取账户结余的当前状态。

## Clojure的状态和标识 ##
在Clojure代码中，状态就是Clojure的数据类型。它们可以是原始类型，例如数字或字符串，或者更为复杂的结构体，包括lists、maps和sets。能作为状态的值的唯一约束是，它们是不可变的。如果使用可变的结构体（例如Java对象）来作为状态，那么你就是在做无用功：Clojure的状态管理是基于值是不变这个前提的，它并不能保障可变对象的一致性和独立性。

标识是使用三个引用类型：refs、agents或atoms/vars来表示。每种引用类型实现了之前提到的概念模型；每种表示一个标识和指向一个状态。它们的差异在于如何更新到指向新状态。使用它们可以处理任何状态更新需求:
  * 使用refs来管理同步、协调状态
  * 使用agents来管理异步、独立状态
  * 使用atomes来管理同步、独立状态

## 协调状态vs.独立状态 ##
很多系统之间一个共同的需求是对某些标识的更新需要协调进行，以保障数据的一致性。协调更新不能单单只考虑一个标识，而必须同时管理多个相互依赖的标识的状态，以保证它们能在同一时间更新，并且不能落下任何一个。协调状态更新最常见的例子是在两个银行账户中转账：钱从一个账户中转出，并转入到另一个账户，这两个操作必须在一个单独的，协调的事件中完成，或者两个都不完成。Clojure使用refs来提供协调状态更新。

与协调状态相反的是独立状态。独立标识的状态更新不会与其它标识的状态更新同时进行。虽然独立标识的状态更新还是需要受控的，但是在内部实现时，要比多个标识的协调更新更加有效。独立标识的更新通常比协调标识的更新更有效率。除非需要协调访问，否则应该尽量使用独立标识。Clojure提供了agents和atoms来作为独立标识的引用类型。

## 同步更新vs.异步更新 ##
同步更新是在同一线程中按顺序进行的，只有在更新完成后程序才继续执行。在Clojure中refs和atoms的值更新都是按同步方式处理的。

异步更新通常在另一个线程中进行。在更新操作被调用后，程序立即执行下一个操作，而不用等待更新操作完成。多使用异步更新能有效提供程序的并发性，并能通过事件机制来提升程序的灵活性。以人的感知角度来看，异步更新可能是瞬间就完成了，但从代码的角度来看，情况并不如此。例如，如果一行代码执行了一个异步标识的更新，并且它的下一行代码立刻就要都这个标识的状态，那么很可能会获取到标识的旧状态。所以在你的代码需要依赖立刻更新的标识的值时，不要使用异步标识。 Clojure提供了agents来作为异步标识的引用类型。

# Refs和事务（Refs and Transactions） #
refs是Clojure对同步-协调标识的实现。每个refs都是一个独立的标识，但是使用它们的操作可以在事务中执行，这保证了多个相互依赖的标识的值可保持一致性。refs可以访问Clojure的先进的STM（软事务内存）系统。

## 创建和访问refs ##
使用内置的ref函数来创建一个ref。ref函数接受一个初始值作为参数，并返回新创建的ref：
```
user=>(def my-ref (ref 5))
#‘user/my-ref
```
这段代码做了两件事情：使用一个整数5作为ref的的初始状态，并将其绑定到一个var,my-ref。这里的重点是：var不是ref本身，它只是绑定到ref。如果你想获取var的值，你会得到如下结果：
```
user=>my-ref
#<Ref@1010058: 5>
```

my-ref是一个var。它仅仅将一个ref绑定为它的值。“#<Ref@1010058: 5>”是ref的调试信息。要获取ref真正的状态，你需要使用deref函数：
```
user=>(deref my-ref)
5
```

deref函数接受单一一个参数，这个参数必须能够被解析为一个ref，函数返回ref的当前状态。因为deref函数会经常被使用，所以有个简式：@符号。使用@符号表示调用deref：
```
user=>(deref my-ref)
5
user=>@my-ref
5
```

在表达式中，这个简式简化了代码：
```
user=>(+ 1 @my-ref)
6
```

反引用一个ref会立刻返回它的状态。ref永远不会被锁定，而且deref不会等待事务完成。deref会返回ref的的当前状态。这意味着如果你在一个事务外调用了deref两次，那很有可能你会得到两个不同的值。

## 更新ref ##
可通过多个不同的函数来更新ref的值。这些函数的差异在于性能，这在下面部分详细描述。它们的共同点在与都必须在事务中执行，如果在事务外执行这些函数，均会抛出异常。

## 事务 ##
Clojure的事务对于那些使用过关系数据库的人来说是一个熟悉的概念。Clojure的事务与关系数据库的事务的性质是相似的。事务的核心是，在一个事务中的所有更新操作要么全部成功，要么一个都不成功，这称为原子性。多个ref值的一致性会得到保证。

事务同时具有隔离性的特点，也就是当一个事务在执行时，其它事务不会看到它所做出的改动。当一个事务启动时，它对所有的ref的值做一个快照。如果在事务执行时，有其它代码对这些值进行更新，那么这些更新不会反应到事务中。反之事务内部做出的更新，在事务提交前也不会被事务外的代码看到。当然，事务自己做出的更新，自己是能看到的。在事务中反引用一个ref通常都是返回ref在这个事务中的值。

另外，如果两个事务互相嵌套。那么被嵌套的内部事务变成嵌套它的外部事务的一部分，并且在外部事务提交时内部事务才提交。

在概念上，事务是无锁定的和乐观的。这意味着事务在启动前并不会等待其它事务完成。事务永远不会阻塞一个正在等待其它更新的线程。然而，很有可能会发生多个事务在更新同一个ref时会产生冲突。一个事务可能已经完成了，但悲剧地发现它所努力更新的ref已经“不新鲜”了，已经被其它事务抢先更新了。在这种情况下，事务只是简单的重试，获取新值的快照并再次执行自己。系统对提交设置了优先级，以保证不论一个ref被多少个事务争着更新，这些事务都保证能够最终完成。

高并发性，高争用的场景通常会导致STM系统效率降低，因为有很多事务需要重试。然而，在多数情况下这还是比使用锁的系统要快。甚至在最坏情况下，虽然一个完美设计的基于锁的系统可能比STM要快，但Clojure认为STM仍然是颇有价值，原因是它减低了复杂度和简化了解决方案。

有很多评论认为STM可与垃圾回收机制媲美。在大多数情形下，它们都足够快，并且它们努力减轻程序员和软件架构师的负担。

## 更新ref的工具（Tools for Updating refs） ##
使用ref最重要的方式是dosync宏。dosync初始化一个事务，并且可接受多个form。每个提供的form都在一个事务中串行执行。最后一个form的值在事务提交后会被返回。如果任意form在执行时抛出异常，这个事务会被结束并不会提交。

要实际执行ref状态更新，可以使用最基本的函数ref-set。ref-set函数接受两个参数：一个ref和一个值。它将ref的状态设置为给定值，然后将值返回。当然，ref-set必须在dosync建立的事务中执行。例如，看如下代码：
```
user=>(def my-ref(ref 5))
#‘user/my-ref
user=>@my-ref
5
user=>(dosync (ref-set my-ref 6))
6
user=>@my-ref
6
```

为了重点强调ref-set和其它ref函数只能在事务中使用。请尝试在事务外调用ref-set函数，它将抛出如下错误：
```
user=>(ref-set my-ref 7)
java.lang.IllegalStateException:No transaction running
```

另一个常用的更新ref状态的函数是alter。alter接受一个ref，一个函数和余下任意数量的参数。它将ref事务内的值作为第一个参数连同给定的其它参数来调用给定的函数（第二个参数输入的函数），然后它将ref的值设置为函数的返回值，最后也将这个值作为自身的返回参数返回给调用者。
```
user=>(def my-ref (ref 5))
#‘user/my-ref
user=>@my-ref
5
user=>(dosync (alter my-ref + 3))
8
user=>@my-ref
8
```

有人可能会问为什么会同时提供ref-set和alter两个函数，它们看起来就是做同样的事情-设置ref的状态。其实它们在功能上并无太多差异，主要差异的地方是给阅读代码的人所提供的感知。alter通常表示ref的新值是基于一个对老值进行运算的函数的返回值。ref-set表示老值被抛弃了，而使用新值来替代。

最后一个用来更新ref的函数是commute。commute与alter函数的外观和基本功能相似，但有一个重要的区别：当发生争用情况时，它不会重启整个事务，而会使用新值来执行计算。这意味着commute函数在高争用的场景中拥有更好的性能。

这也意味着commute操作是不能完美地在一个事务中隔离的。然而，如果传递给commute的函数在逻辑上或数学上是可交换的，那么就没什么不同。
可交换函数指的的是那些可按任何顺序调用而不会影响最终结果的函数。在使用commute的竞争性事务中，这正是会发生的事情。commute通过假设它可与其它更新一起被按照任何顺序来执行更新来获得有效性的。所以，你只应该在给提供的函数可以按照任意顺序执行而不会影响结果的情况下使用commute。如果你在commute上使用了一个不能保证逻辑上可交换的函数，那么你很可能会发现不一致、不可预知的行为。

下面给出一个正确使用commute的例子（因为+是一个符合交换律的操作）：
```
user=>(def my-ref(ref 5))
#‘user/my-ref
user=>@my-ref
5
user=>(dosync(commute my-ref + 3))
8
user=>@my-ref
8
```

还有一个用于处理ref的函数：ensure。它接受一个ref作为参数。与其它ref函数一样，它只能在事务中执行。与其它ref函数不同的是，它并不真正改变ref的状态。ensure函数实际做的事情是确保一个事务在ref变化的时候重试。....

### 例子 ###


# Atoms #
Clojure提供atom来实现同步-非协调的标识。当atom标识被更新时，当前执行线程的后续代码在更新后才执行，并且atom标识的更新是原子性的。后续其它线程反引用atom的值时都会获得新值。
atom是基于Java的java.util.concurrent.atomic包中的类库来实现的。这些类库提供了在竞争情况下更新值的原子性。

实际上，atom与ref的用法类似，除了它们本质上是非协调的，所以不需要在事务中使用。

## 使用Atoms ##
要创建一个atom，请使用atom函数。atom函数接受一个值参数作为atom标识的初始值，并返回atom标识。要获取atom的值，可以使用deref函数或这@简式。
```
user=>(def my-atom (atom 5))
#‘user/my-atom
user=>@my-atom
5
```

与ref相似，有两种更新atom值的方法：swap!和reset!。swap!函数接受一个atom，一个函数和余下多个参数。swap!函数使用atom和其它参数来调用给定的函数，并将函数的返回值设置到atom，最后返回atom的值。给定的函数（第二个参数）可能会被调用多次，所以必须保证它不会产生负作用。

下面的例子使用前一个例子定义的atom：
```
user=>(swap! my-atom + 3)
8
user=>@my-atom
8
```
reset!函数直接设置atom的值，而不理会atom的旧值。它接受两个参数（atom和新值）并返回atom的新值。
```
user=>(reset! my-atom 1)
1
user=>@my-atom
1
```

## 什么时候使用Atoms ##
在实际情况中，atoms并不如refs那样被频繁使用。Since they can’t coordinate with other pieces of state,their usefulness is limited to scenarios in which an identity is truly,logically independent from other identities in the system.

在标识是独立的情形下，atom是正确的选择。它们避免了ref所带来的消耗，并且非常快速，特别对于读取操作。它们没有agents的parallelism implications。总的来说atom是Clojure中标识类型中最轻量级的。
在需要缓存值的情形下，atom非常有用。缓存值需要能够被快速访问，但不能依赖系统的其它状态。Clojure的memorize函数（将一个函数的结果进行缓存，在第14章详细描述）在内部使用atom来维护它的缓存。

# 异步Agents #
Agent是Clojure独特的强大的特性。像refs和atoms，agents是标识，并且严格遵守Clojure的标识和状态分离思想。然而，与refs和atoms不同的是，对agents的值的更新是在一个系统管理的线程池中异步执行，这个线程池是专为惯例agent状态而设立的。

这意味着agents不仅是一种在并发环境下存储和管理状态的手段，而且是为程序引入并发的一个工具。使用agents时，不需要手工创建线程、管理线程池或显示地发起任何其它种类的并发机制。agents是标识类型，它的使用和更新就如同refs或atoms般简单，而且它更具有“免费”的并发性特点。

## 创建和更新agents ##
使用agent函数来创建agents。agent函数接受一个值作为参数，并返回新创建的以指定参数值为初始状态的agent。如同其它Clojure的标识类型，给定的值应该是不可变的。
```
user=>(def my-agent (agent 5))
#‘user/my-agent
```

同时与其它Clojure标识类型相似的是，一个agent的当前值可以使用deref（或@简式）函数来获取，值的获取同样是非阻塞的。
```
user=>@my-agent
5
```

agent的值的更新操作是通过使用send或send-off函数来发布一个动作函数的方式来实现的。send函数被调用后会立刻返回（将agent本身作为返回参数）。在某个未知的时间点，在另一个线程，提供给send函数的动作函数会被调用，然后它的返回值将作为agent的新值被绑定到agent上。

send函数能够接受多个参数。它的前两个参数分别是agent和动作函数，其余的参数将作为调用动作函数时当做输出参数依次传递给动作函数。例如，向之前定义的agent发送一个更新：
```
user=>(send my-agent + 3)
#‘user/my-agent
```

然后，在某个时刻，agent的新值可以被获取：
```
user=>@my-agent
8
```

什么时候执行更新动作呢？这并没有硬性的保证。虽然人会感觉到几乎是立刻执行更新操作。记得在任何时候都千万不要编写那些假设一个agent的值已经被更新的代码。agent是异步的，并且不能保证它的更新操作什么时候执行。

send-off函数与send函数有相似的外观和行为。唯一不同的是两个函数在性能要求上有不同的侧重。对于需要大量CPU资源的动作，请使用send函数。而对于会花费很多时间阻塞在IO上的动作，请使用send-off函数。这使得agent运行时能够做出响应的优化。如果你使用了“错误”的函数，虽然所有东西都会正常工作，但是整个agent系统的吞吐量会降低，因为它会为错误的动作类型做错误的优化。

## 更新语法 ##
虽然agents不能保证一个对它进行操作的动作什么时间能够执行，但是更新分派还是遵循了一些可被信赖的规则：
  * 对单个agent所作的动作都被串行执行，而不是并发执行。多个对同一个agent进行更新的动作是不会相互覆盖结果的或者是产生并发竞争问题。
  * 从同一个线程发出的对一个agent的多个操作，会按照它们发出的顺序来执行。显然对于多个线程发出的操作，则没有这样的保证。
  * 如果一个动作函数包含了对其它agent的分派操作，不论是对它自己的agent还是别的agent，这些分派都会被保存，直到这个动作函数完成并且agent的值被更新后，才会被真正启动。这个规则允许一个动作函数触发其它动作，而不会产生更新冲突。
  * 如果一个agent的更新动作在STM事务中被派发（例如，在dosync表达式中），那么这个动作会等到事务结束后才真正被分派。这表示在STM事务中能够安全的分派对atoms的更新。

## 错误和Agents ##
因为agent的动作函数都是在另一个线程中异步执行的，所以它们需要特殊的错误处理机制。通常，异常是在当前线程的异常发生点抛出的，但是当动作函数抛出异常时，除非通过内置的agent错误处理机制，否则并没有办法捕捉这些异常。

agents能够包含两种失败模式中的一种，这两种模式是:fail或:continue。如果agent的失败模式是:continue，那么当动作函数排除异常时。在执行了一个可选的错误处理函数后，agent保持不变，就像异常没发生过。如果错误模式是:fail，那么agent会被设置一个错误状态，并且在其重新启动前不会再接受任何动作（虽然agent会保存它当前的动作队列）。

缺省情况下，如果一个agent带有一个错误处理函数，那么它的失败模式就是:continue。相反则缺省是:fail。agent的失败模式可以使用set-error-mode!函数来设置，这个函数接受两个参数，一个是agent，另一个是模式的关键字。例如：
```
user=>(set-error-mode! my-agent :continue)
nil
你可以获取agent当前的失败模式，使用error-mode函数：
user=>(error-mode my-agent)
:continue
```

可以通过使用set-error-handler!函数来想agent设置一个错误处理器。set-error-handler!函数接受一个agent和一个错误函数作为参数。当一个动作抛出一场或者将agent的状态设置为一个异常值时，这个错误函数将会被调用。错误函数本身接受两个参数：一个agent和一个异常对象。例如，下列代码：
```
user=>(set-error-handler! my-agent (fn [agt ex] (...))
nil
```
通常，错误处理函数被用来记录错误或者实现一些修正机制来保证同类异常不会再次发生。你也可以使用error-handler函数来获取agent当前的错误处理函数。error-handler函数接受一个agent作为参数，并返回agent的错误处理函数。

### 处理处于失败状态的agent ###
如果对处于失败状态的agent调用send或send-off函数调用，那么agent会抛出异常（虽然对agent的反引用还是能获取agent最后一次的正确值）。例如：以下例子中的除以0操作会导致agent进入失败状态：
```
user=>(def an-agent (agent 10))
#'user/an-agent
user=>(send an-agent / 0)
#<Agent@1afa486: 10>
user=>(send an-agent + 1)
java.lang.RuntimeException: Agent is failed,needs restart
```
如果要检查agent当前的错误情况，我们可以使用agent-error函数，它接受一个agent作为唯一的参数：
```
user=>(agent-error an-agent)
#<ArithmeticException java.lang.ArithmeticException: Divide by zero>
```
为了将agent重新放入正常状态，你必须调用restart-agent函数。restart-agent函数接受一个agent、一个新状态和任意数量的其它关键字-值对作为参数。当前支持的关键字-值对是:clear-actions关键字对应一个布尔值。
当restart-agent函数被调用时，这个函数将agent的状态设置为给定的状态，并移除agent的错误状态，这样agent就可以重新接受新的动作了。如果:clear-actions设置为true，那么agent的动作队列会被清空；否则，正在等待的动作会比串行式地调用。restart-agent函数返回agent的新状态作为返回参数。
将之前例子中的agent进行重置：
```
user=>(restart-agent my-agent 5 :clear-actions true)
5
```
现在，可以向这个agent发送更多动作：
```
user=>(send my-agent + 1)
#<Agent@1365360: 5>
user=>@my-agent
6
```
### 等待agent ###
虽然agent本质上是异步的，但是偶尔还是需要一定程度的同步。例如，对于一个长时间运行在某个agent上的动作，原来发布动作的线程可能需要等待动作的结果才能继续执行。为了实现这个目的，Clojure提供了await和await-for函数。这两个函数都会阻塞线程，直到agent完成处理它的动作为止。
await函数接受任何数量的agent作为它的参数，并阻塞当前线程直到所有提供的agent的动作（由当前线程分派的）都完成为止。await函数返回nil。
await-for函数几乎一样，除了它还额外接受一个超时（以毫秒为单位）作为它的首个参数。如果在等待所有agent的时候已经超时了，那么await-for函数返回nil。否则它返回一个非nil值。
### 关闭agent ###
无论在Clojure程序中agent何时被使用，Clojure运行时都会创建一个线程池来在背后运行agent的动作。通常，你并不需要关心这些细节，除了一个Java/Clojure程序由于一个活动的线程池的存在，而不会正常的结束。为了使agent线程池失效，你可以调用shutdown-agents函数。当前所有活动中的动作能正常完成，但是不会再有新的动作会被接受。当所有动作都完成后，线程池会关闭，从而允许程序结束。
除非你确定要结束正在运行的程序，否则永远不要调用shutdown-agent函数。shutdown-agents函数是不可取消的，除非重新启动你的程序。并且在调用后，agent不可以再被更新：调用send或
send-off将会抛出异常。
### 什么时候使用agent ###
当你正在思考什么时候使用agent时，请记住agent并不是用来管理状态的手段，而是用来管理程序执行的手段。使用agent并不意味着仅仅是管理标识的状态，而且时将计算过程分散到多个线程中去。
作为状态管理的工具，agent是有效的，虽然他们并不具备refs的所有特性，例如事务性和数据一致性。agent本身时非协调的标识类型。对于真正需要事务性和一致性的数据，请你绝对要考虑使用refs。类似地，对于简单的非协调状态管理，agent并不比atom功能更强大。如果你需要的仅仅时保证状态的完整性，那么atom要比agent更为合适。
agent的重要特性不仅仅在于他们保护状态，而且更在于对状态的操作是与分派更新请求的线程并行运行的。正如之前例子中提到的，如果分派到agent的动作是简单和运行快速的，例如+，那么使用agent并不能带来什么优势。但是当操作是非常耗时的，或者它们执行IO操作（在事物中不允许），那么使用agent将带来巨大的好处。每个分派给agent的动作都与当前线程分离，使得当前线程可以处理其它更重要的任务。
并发性时agent最重要的特性。agent的状态管理在其并发性特性下变得非常方便和工作良好，并且并发性是选择agent而不是其它Clojure标识类型的主要考量因素。
## Var和线程本地状态 ##
除了ref、atom和agent，Clojure还有第四种“修改”状态的方式：线程本地var绑定。由于var是线程本地的，所以它们不能在线程之间共享状态。
var是普通绑定（在第一章讨论过，由def创建），也就是它们在同一线程来可以被重新绑定，并遵循栈规则。这允许一定程度上的命令式风格变成。var时Clojure中唯一能够不使用引用类型来“修改”一个变量的方式。
要给一个var建立线程本地的绑定，使用binding形式。binding接受一个绑定向量和一或多个表达式。绑定向量包含了一串符号-值对。表达式在一个隐含的do里面执行，表达式中用到的符号会在绑定向量中寻找。绑定只能用在预先用def定义的var上。例如：
```
user=>(def x 5)
#'user/x
user=>(def y 3)
#'user/y
user=>(binding [x 2 y 1] (+ x y))
3
user=>(+ x y)
8
```
在绑定表达式内部，(+ x y)得出结果3.在绑定表达式外，(+ x y)使用了原来的var的值，所以结果是8。
到目前为止，绑定可能看起来与let类似。它们的区别在于，绑定不是建立一个本地符号，而是重新绑定var的值。例如，看看以下例子：
```
user=>(def x 5)
#'user/x
user=>(def y 3)
#'user/y
user=>(defn get-val [] (+ x y))
#'user/get-val
user=>(get-val)
8
user=>(binding [x 1 y 2] (get-val))
3
```
绑定实际上时重新建立了x和y的值。当get-val函数在绑定形式内部被使用时，它选择线程本地绑定的x和y来使用。
此外，绑定中的符号绑定可以使用set!函数来更新（与其它编程语言中的命令式变量类似）。以下例子有点长，但是它揭视了独立的代码如何更新同一个绑定：
```
user=>(def x 5)
#'user/x
user=>(def y 3)
#'user/y
user=>(defn set-val [] (set! x 10))
#'user/set-val
user=>(defn get-val[] (+ x y))
#'user/get-val
user=>(binding [x 1 y 2] (set-val) (get-val))
12
```
注意set-val是如何被首先调用的，并且x的值被重新设置为10，所以当get-val在后面使用时，它使用了被更新的值。在绑定形式中，所有被绑定的符号的引用都能看到set!造成的修改。
### 什么时候使用线程本地var ###
在Clojure中很少地方能适合使用线程本地状态。大量使用线程本地状态违背了函数式变成的精神。所以这个功能仅仅是作为在某些特别情况下用来提升性能的手段。
  * 对某些算法来说，将状态堪称时可变的变量，可能会让算法看起来更有逻辑性和便利性。这样的例子包括解析器和状态机。通常，实现同样算法功能的，功能性算法时存在的，只是它们对于来自命令式编程北京的程序员来说，不是十分明显
  * 在真正标识线程本地语义的地方，基于上下文的值可变化。例如，对于很多Clojure运行时的设置是保存在var绑定中的，这样可以很方便的在任何代码中都使用set!来设置新值。其中一个例子时\*out