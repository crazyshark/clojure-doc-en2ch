#Clojure的数据

= Clojure的数据 =

如何表示和处理数据

Clojure是一种动态类型语言，这意味着你在程序中永远不需要明确定义符号、函数、或者参数的数据类型。但是，所有的值仍然有一个类型。字符串时是字符串，数字是数字，列表是列表，等等。如果你尝试执行一个类型不支持的操作，将会在运行时产生错误。写代码时避免这种事情，是程序员的责任。对于有动态语言背景的人来说是很自然的事情，而那些只使用静态语言的人需要一些转变。

Clojure的类型既简单又复杂。Clojure的本身只有少量不同的类型，而且Clojure不是面向对象语言，它本身并不支创建新的用户自定义类型。一般来说，这让事情非常简单。但是，Clojure运行在Java虚拟机上，在内部每个Clojure的类型也表现为一个Java的类或接口。此外，如果你关联了一个Java库，你可能要注意Java类和类型。幸运的是，通常你只需要在Clojure中关联Java代码时关注它。
	
 表4-1. Clojure的内置类型
 
||  *类型*			|| *描述*              ||	*例子*                   ||	*内部Java类/接口*             ||
|| Number		|| 数字本身           ||	16                        ||	java.lang.Number             ||
|| String			|| 用双引号包围	   || "Hello!"                   ||	java.lang.String                ||
|| Boolean		|| true 或者 false  ||	true                      || ava.lang.Boolean              ||
|| Character		|| 前缀一个反斜线  || \a                          ||	java.lang.Character          ||
|| Keyword		|| 前缀一个冒号	   || :key	                    ||  clojure.lang.Keyword       ||
|| List			|| 括号		   ||	'( 1 2 3 )                 ||                                         ||
|| Vector			|| 方括号              ||	`[ 1 2 3 ]`                  ||                                         ||
|| Map			|| 花括号              ||	{:key val :key val}  ||	java.util.Map                    ||
|| Set			|| 花括号前缀井号 || #{ 1 2 3 }                  ||	java.util.Set                      ||

Nil
	保留符号nil在Clojure程序中有特殊的意义：它的意思是“空”或“空值”。	当nil用于布尔表达式计算和空判断时永远返回false，但是它不等于它自己。
	它可用于任何数据类型，包括原语。但是，传递nil给大多数函数或操作将导致一个错误，因为它不是一个真正的值。
	如果一个值有可能是nil，你就需要考虑代码中的这种特殊情况，以避免这个操作会产生一个java.lang.NullPointerException错误。
	nil和Java中的Null是相同的。
	
基本类型
	Clojure提供了一些基本类型来表示基本程序语言的类型结构，比如数字，字符串和布尔值。
	
Numbers

Clojure 对数值和数值计算有非常好的支持，数字常量能够用多种方式表示：

    * 标准计数法的整形和浮点小数直接作为数字类型。例如，42或者3.14159。
    * Clojure还支持直接使用/符号输入比率常量。例如，5 / 8或3 / 4。用比率输入的常量将会自动简化。如果你输入4 / 2，将被简单的存储为2。
    * 你能够以基数+r+值的形式输入任何整型常量。例如，2r10是二进制的2，16rFF是十六进制的255，你甚至可以输入像36r0Z这样的东西，这是35的36进制表示。语言支持2到36之间的所有基数。
    * Clojure还支持ava传统的十六进制和八进制表示法。数字前缀0x是十六进制表示：例如，0xFF是255。数字前缀0的都被为是八进制。
    * 任何计算机上，对于十进制数都有两种表示法：浮点数和一个精确的十进制值。Clojure和Java一样，默认使用浮点数表示法，也不支持精确计算，内部使用Java的java.math.BigDecimal类。要指定一个常量内部使用恰当的精确形式，需要在数字后边添加一个M。例如，1.25M。与浮动点不同的是，这些数字将被四舍五入操作。这使得他们大多数的时候更加适用于货币。
----
*警告*  因为Clojure使用Java的整型字面量约定，前缀0的数字被认为是八进制数，如果你强制输入类似09这样的数字会返回一个错误，因为它不是有效的八进制数。
----
    在涉及到不同类型的数字的运算时，Clojure会自动将结果转换到最精确的类型。例如，当整数和浮点数相乘时，结果将是浮点数。除法运算总是返回一个比率，除非其中一项是个十进制数，结果会被转换成浮点数。

    数字没有最大值的限制。Clojure会自动转换为最合适的内部表示形式来表示越来越大的数字，处理任何数字都没有问题。然而，在高性能应用中要注意，当操作的数据大小超过Java Long类型时，也就是数字超过9,223,372,036,854,775,807时，你可能会感到运行缓慢。这种需要不同内部表示的形式对于高速数学运算不是高效的，即使它是足以满足大多数任务。尽管它足以满足绝大多数任务。
	
常见数值函数

这些函数提供了对数字的数学运算。

注释  为保持简单，Clojure API中的计算函数与其他语言的常见运算是一致的。但不用担心：当表达式被解析和编译时，它们会被替换为优化的Java字节码，尽可能使用原始运算。为保持简单作为函数的数学运算没有损失任何速度。

加法 (+)

加法函数(+)接受任意数值类型的参数，返回它们的和。
{{{
(+ 2 2)
-> 4
(+ 1 2 3)
-> 6
}}}

减法 (-)

减法函数(-)接受任意数值类型的参数。如果只有一个参数，则返回它相反的数。当有多个参数时，返回第一个参数减去后面所有参数的结果。
{{{
(- 5)
-> -5
(- 5 1)
-> 4
(- 5 2 1)
-> 2
}}}

乘法 (`*`)

乘法函数 (`*`) 接受任意数值类型的参数并返回它们的乘积。
{{{
(* 5 5)
-> 25
(* 5 5 2)
-> 50
}}}

除法 (/)

除法函数 (/) 接受任意数值类型的参数。第一个参数是分子，其他任意参数是分母。如果没有分母，则函数返回 1 / 分子，否则返回分子除以分母。
{{{
(/ 10)
-> 1/10
(/ 1.0 10)
-> 0.1
(/ 10 2)
-> 5
(/ 10 2 2)
-> 5/2
}}}

增量

增量函数 (inc) 接受一个数值类型参数并返回它的值加1。
{{{
(inc 5)
-> 6
}}}

减量

减量函数 (dec) 接受一个数值类型参数并返回它的值减1。
{{{
(dec 5)
-> 4
}}}


商

商函数 (quot) 接受两个数值类型参数并返回第一个参数除以第二个参数的整数商。
{{{
(quot 5 2)
-> 2
}}}

余

余数/模数函数 (rem) 接受两个数值类型参数并返回第一个参数除以第二个参数的余数。
{{{
(rem 5 2)
-> 1
}}}

最小数

最小数函数 (min) 接受任意数值类型的参数并返回最小的。
{{{
(min 5 10 2)
-> 2
}}}

最大数

最大数函数 (max) 接受任意数值类型的参数并返回最大的。
{{{
(max 5 10 2)
-> 10
}}}
	
等于 (==)

等于函数 (==) 接受任意数值类型的参数，如果它们相等返回ture，否则返回flase。
{{{
(== 5 5.0)
-> true
}}}

小于 (<)

小于函数 (<) 接受任意数值类型的参数，如果它们按升序排列返回true，否则返回false。
{{{
(< 5 10)
-> true
(< 5 10 9)
-> false
}}}

小于等于 (<=)

小于等于函数 (<=) 接受任意数值类型的参数，如果它们按升序排列或顺序相等返回true，否则返回false。
{{{
(<= 5 5 10)
-> true
}}}

大于 (>)

大于函数 (>) 接受任意数值类型的参数，如果它们按降序排列返回true，否则返回false。
{{{
(> 10 5)
-> true
}}}

大于等于 (>=)

大于等于函数 (>=) 接受任意数值类型的参数，如果它们按降序排列或顺序相等返回true，否则返回false。
{{{
(>= 10 5 5)
-> true
}}}

0检查

0检查函数 (zero?) 接受一个数值类型参数，如果是0返回true，否则返回false。
{{{
(zero? 0.0)
-> true
}}}

正数检查

正数检查函数 (pos?) 接受一个数值类型参数，如果是大于0返回true，否则返回false。
{{{
(pos? 5)
-> true
}}}

负数检查

负数检查函数 (neg?) 接受一个数值类型参数，如果是小于0返回true，否则返回false。
{{{
(neg? -5)
-> true
}}}

数值检查

数值检查函数 (number?) 接受一个参数，如果是数值返回true，否则返回false。
{{{
(number? 5)
-> true
(number? "hello")
-> false
}}}

字符串

Clojure字符串和Java字符串相同，都是java.lang.String类的实例。它们作为文本输入，用双引号括起来。如果需要在字符串中写双引号字符，可以使用反斜杠字符进行转义，\.例如，下面这个有效的字符串：
{{{
"Most programmers write a \"Hello World\" program when they learn a new language"
}}}
在字符串中输入反斜杠字符，只需输入两个反斜杠。

常用字符串函数

Clojure仅提供了少量方便的字符串函数。对于更高级的字符串操作，你既可以使用Java字符串API（参见本章与Java的交互操作），也可以使用clojure.contrib用户库的str-utils命名空间定义的各种各样的字符串工具函数。

连接

字符串连接函数 (str) 接受任意数量的参数。如果参数不是字符串则将其转换为字符串，返回连接创建的新字符串。如果没有参数或为nil，则返回空字符串，""。
{{{
(str "I have " 5 " books.")
-> "I have 5 books."
}}}

子串

子字符串函数 (subs) 接受两个或三个参数, 第一个是字符串，第二个是一个整数偏移量，第三个（可选）是另一个整数偏移量。函数返回从第一个偏移量（含），到第二个（不含）偏移量或者结尾（如果没有第二个偏移量）截取的子字符串。
{{{
(subs "Hello World" 6)
-> "World"
(subs "Hello World" 0 5)
-> "Hello"
}}}

字符串检查

字符串检查函数 (string?) 接受一个参数，如果是字符串返回true，否则返回false。
{{{
(string? "test")
-> true
(string? 5)
-> false
}}}

打印与换行打印

字符串打印函数 (print & println) 接受任意数量参数，打印到标准系统输出（如果不是字符串则转换成字符串）。println 在尾部追加一个换行符。两个函数都返回nil。

正则表达式函数

Clojure提供了一些函数用于处理正则表达式，包装了Java正则表达式实现。

re-pattern

函数 (re-pattern) 接受一个字符串参数，返回一个正则表达式样式(java.util.regex.Pattern类的实例）。这个样式能用于正则表达式匹配。
{{{
(re-pattern " [a-zA-Z]*")
-> #"[a-zA-Z]*"
}}}

也可以使用读取宏来直接用文本的方式输入正则表达式：在字符串前使用#符号。结果同样是样式，和用re-pattern函数生成的一样，例如，下面的表示方式和前面的例子是相同的：
{{{
#" [a-zA-Z]* "
-> #"[a-zA-Z]*"
}}}

re-matches

re-matches接受两个参数：一个正则表达式样式和一个字符串。返回任何和正则表达式样式匹配的字符串，如果没有匹配则返回nil。例如下面的代码：
{{{
(re-matches #"[a-zA-Z]* " "test")
-> "test"
(re-matches #"[a-zA-Z]* " "test123")
-> nil
}}}

re-matcher

re-matcher接受两个参数：一个正则表达式样式和一个字符串。返回一个有状态的"matcher"对象，提供给其它正则函数而不是直接提供样式。Matchers是java.util.regex.Matcher.类的实例。
{{{
(def my-matcher (re-matcher #" [a-zA-Z]* " "test")
-> #'user/my-matcher
}}}

re-find

re-find接受一个样式与一个字符串或者一个matcher。每次调用，返回matcher中下一个符合正则匹配的结果（如果还有）。
{{{
(re-find my-matcher)
-> "test"
(re-find my-matcher)
-> ""
(re-find my-matcher)
-> nil
}}}

re-groups

接受一个matcher，返回从接近的发现与匹配的集合。如果没有嵌套集合，则返回一个完全匹配的字符串。如果有嵌套集合，则返回vector集合，第一个元素是完全匹配的（非嵌套）。

re-seq

re-seq接受一个样式与一个字符串。它返回一个使用永久匹配（matcher）的lazy sequence(懒序列 见第5章)（这个sequence在一个连续的样式匹配的字符串中）。
{{{
(re-seq #" [a-z] " "test")
-> ("t" "e” "s" "t")
}}}

布尔

布尔值在Clojure中非常简单。使用文本值的保留符号true和false，并使用java.lang.Boolean类作为底层。当计算其它数据类型的布尔表达式的时候，所有数据类型（包括空字符串、空集合、和数值0）均按true计算。除了实际布尔值false，计算结果为false的都是空值 nil。

常用布尔函数

Clojure提供了一些方便的布尔函数。

not

not 函数(not) 接受一个参数。如果逻辑计算结果是false则返回true，如果逻辑计算结果是true则返回false。
{{{
(not (== 5 5))
-> false
}}}

and

and宏接受任意数量参数，如果每个逻辑计算结果都为true则返回true，反之为false。为保证效率，如果第一个参数的结果是false，则直接返回false而不再计算其他参数。
{{{
(and (== 5 5) (< 1 2))
-> true
}}}

or

or宏接受任意数量参数，如果参数逻辑结果有一个或多个为true则返回true，反之为false。 为保证效率，只要一个参数的逻辑结果为true，就返回true而不再计算其他参数。
{{{
(or (== 5 5) (== 5 4))
-> true
}}}


字符

字符用来表示单个Unicode字符。输入一个字符文本，前缀一个反斜杠，例如，\i是字符"i"。任何Unicode字符都能用一个反斜杠，加上一个'u'和Unicode字符的四位十六进制代码输入。
例如，\u00A3是£符号。Clojure也很容易输入空白字符文本，支持下列特殊值：\newline（新行），\space（空格）和\tab（制表符）。

Char

字符强制转换函数 (char) 接受一个整型参数并返回对应的ASCII/Unicode字符。
{{{
(char 97)
-> \a
}}}

Keywords

关键字是Clojure中唯一特殊的的原始数据类型。主要目的是提供非常高效的存储和相等判断。因此，关键字理想的用途是作为map数据结构的key或者其它简单“标记”功能。作为文本，关键字在开头带冒号，例如:keyword。在冒号后面，它们遵循和符号相同的命名规则（见第2章）。

关键字能够作为命名空间（可选的）。如关键字:user/foo，是指在user命名空间中叫做foo的关键字.命名空间关键字能够通过输入完全限定名或前缀两个冒号在当前命名空间中查询来引用（例如，如果当前命名空间都是user，::foo 和:user/foo 是相同的）。

keyword

关键字函数 (keyword) 接受一个字符串参数，并返回一个同名的关键字。如果有两个参数，返回一个带命名空间的关键字。
{{{
(keyword "hello")
-> :hello用法
(keyword "foo" "bar")
-> :foo/bar
}}}

keyword?

关键字检查函数接受一个参数，如果是关键字返回true，否则返回false。
{{{
(keyword? :hello)
-> true
	namespace
…....
}}}