#summary Practical Clojure Chapter 14 Performance.
= Chapter 14 性能 =

    在原理上，Clojure能够跟java一样快:两者都是编译成java字节码，运行在java虚拟机上面。Clojure的设计小心地避免了某些特性－－比如连等式，或者类似Common Lisp的条件系统－－这些在jvm上面会严重地危害性能。但Clojure始终是一门年青的语言，并没有耗费成千上万小时去优化编译器。这样的结果是，Clojure的代码通常比等价的java代码运行得要慢些。然而，通过某些细微的调整，Clojure的性能表现能被带到接近java的水平。不要忘记java从代码层面来说，在性能临界上的表现总是可靠的。

*JVM上概要分析*
---------------
    评估任何程序语言或者算法性能的首要原则就是：测试！
    
    不要假设一项技术必然更快因为它似乎拥有更少的步骤或者采用更少的变量。但这在现代的JVM比如Hotspot上面是对的，JVM在程序运行的过程中不断地估算代码的性能，动态地重新编译临界区。

    所谓的微基准，即在隔离条件下测量某个单独操作，在当前的环境下是没有意义的。同样，以JVM初始化启动时间做为标准的测量也是没有意义的（这个错误通常发生在对比java和C++时）。现代的JVM通常针对吞吐量进行优化，最大化了操作的总量，哪怕是有可能要花很长一段时间来执行的操作。


*JAVA性能的一般技巧*
--------------------
    java虚拟机有一堆可以影响性能的选项。首先，JVM要区分“客户端”和“服务端”模式，“服务端”模式的性能全面超越“客户端”（代价是更长的启动时间）。

    其次，Java堆空间的大小和选择不同的垃圾收集器策略同样影响性能。这对于Clojure来说尤为真实，因为比起Java来，Clojure对常量的频繁使用会占用更多的堆空间，也会给垃圾收集造成更大的压力。

    在现代JVM中有更多可调整的参数会影响性能。你要确保很熟悉虚拟机提供给你的“性能开关”，并且尝试着观察它们如何影响你实际应用的性能。

    
*采用Time进行简单性能测试*
----------------------
    Clojure拥有一个内建的简单性能测试工具，time宏。time接受一个简单表达式，分析它，然后打印出执行表达式将耗费多少毫秒：
user=> (time (reduce + (range 100))) 

"Elapsed time: 1.005 msecs" 

4950 

    就像我们之前提到的，这个测试宏在JVM上下文中几乎没什么意义。来个稍微好点的测试，测试一下在一个闭合循环中重复执行上万次计算：
user=> (time (dotimes `[i 100000`] 
               (reduce + (range 100)))) 
"Elapsed time: 252.594 msecs" 

nil 

    然而，这依然不能统观全貌，因为JVM可能在执行循环的过程中就对计算进行了优化。多次重复循环就能得到一个更加精确的结果：
user=> (dotimes [j 5] 
         (time (dotimes [i 100000] 
                 (reduce + (range 100))))) 
"Elapsed time: 355.759 msecs" 

"Elapsed time: 239.404 msecs" 

"Elapsed time: 217.362 msecs" 

"Elapsed time: 221.168 msecs" 

"Elapsed time: 217.753 msecs"

    如同你看到的那样，在这个例子中，数次迭代的执行时间基本上在220毫秒上下波动。这种模式就是JVM的特点。

    然而，即使拥有了这些信息，你仍然无法准确预期在一个大的应用上下文中，(reduce + (range 100))这个计算的性能如何。只能执行更多的测试来验证了。

    同样地，我们也得意识到延迟序列（lazy sequences）对于性能的影响。如果你用来测试的表达式采用了延迟序列（比如：map），time宏可能就只会给出初始化序列的时间。为了计算出获得整个序列的时间，你必须采用doall。但doall在复杂的数据结构中很难执行，而且获得的结果并不代表数据结构实际使用的性能。


*采用java性能工具*
------------------
    因为Clojure被编译成java字节码，java的性能工具同样可以在Clojure中使用，但是关于这些工具的讨论已经超出了这本书的讨论范围。

    最佳的经验法则如下：采用最直接、最简单的方式编写你的代码，然后测试看看是否达到预期性能。如果没有，采用性能工具去确定影响性能的关键点，然后迁移或者重写这些点上的代码直到满足你的性能需求。接下来的几页会描述一些分析性能关键点的技术。

*备忘*
------
    有一项能够加速大型复杂函数的简单技术叫做备忘（memoization），这是某种形式的缓存。当每次调用函数时，一个备忘函数会在table中储存被调函数的输入参数以及返回值。如果这个函数以同样的输入参数被再次调用时，它返回的就是储存在table中的值而不需要再次进行计算。

    Clojure内建支持备忘的函数是memoize，它接收一个函数做为参数，返回这个函数的备忘版本:
(defn really-slow-function `[x y z`] ...) 

(def faster-function (memoize really-slow-function)) 

    备忘是一个牺牲内存加速执行的经典例子。如果一个函数需要花费比哈希表寻址更多的时间去计算结果，而且它又经常以同样的输入参数被调用，那么采用备忘就是一种好的候选方案。只有纯函数－－意即针对特定输入总是返回同样结果的函数－－能够进行备忘。

    
*反射和类型提示*
----------------
    就像你所知的那样，java是种静态类型语言：它是在编译时确定所有对象的类型。而Clojure是动态类型，意即某些对象的类型一直要到运行时才会确定。

    要在静态类型的java上面实现动态类型的函数调用，Clojure采用了java的反射特性。反射允许代码在运行时查阅java的类并根据名字来调用方法。然而，通过反射调用方法比直接调用编译后的方法要慢上很多。

    Clojure允许你为符号和表达式加上类型提示以避免编译器通过反射调用方法。类型提示采用:tag关键字通过读取时元数据来进行声明。一个类型提示的symbol可以写成#^{:tag hint} symbol，通常简写为#^hint symbol。