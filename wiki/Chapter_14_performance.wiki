#summary Practical Clojure Chapter 14 Performance.
= Chapter 14 性能 =

    在原理上，Clojure能够跟java一样快:两者都是编译成java字节码，运行在java虚拟机上面。Clojure的设计小心地避免了某些特性－－比如连等式，或者类似Common Lisp的条件系统－－这些在jvm上面会严重地危害性能。但Clojure始终是一门年青的语言，并没有耗费成千上万小时去优化编译器。这样的结果是，Clojure的代码通常比等价的java代码运行得要慢些。然而，通过某些细微的调整，Clojure的性能表现能被带到接近java的水平。不要忘记java从代码层面来说，在性能临界上的表现总是可靠的。

*JVM上概要分析*
---------------
    评估任何程序语言或者算法性能的首要原则就是：测试！
    
    不要假设一项技术必然更快因为它似乎拥有更少的步骤或者采用更少的变量。但这在现代的JVM比如Hotspot上面是对的，JVM在程序运行的过程中不断地估算代码的性能，动态地重新编译临界区。

    所谓的微基准，即在隔离条件下测量某个单独操作，在当前的环境下是没有意义的。同样，以JVM初始化启动时间做为标准的测量也是没有意义的（这个错误通常发生在对比java和C++时）。现代的JVM通常针对吞吐量进行优化，最大化了操作的总量，哪怕是有可能要花很长一段时间来执行的操作。


*JAVA性能的一般技巧*
--------------------
    java虚拟机有一堆可以影响性能的选项。首先，JVM要区分“客户端”和“服务端”模式，“服务端”模式的性能全面超越“客户端”（代价是更长的启动时间）。

    其次，Java堆空间的大小和选择不同的垃圾收集器策略同样影响性能。这对于Clojure来说尤为真实，因为比起Java来，Clojure对常量的频繁使用会占用更多的堆空间，也会给垃圾收集造成更大的压力。

    在现代JVM中有更多可调整的参数会影响性能。你要确保很熟悉虚拟机提供给你的“性能开关”，并且尝试着观察它们如何影响你实际应用的性能。

    
*采用Time进行简单性能测试*
----------------------
    Clojure拥有一个内建的简单性能测试工具，time宏。time接受一个简单表达式，分析它，然后打印出执行表达式将耗费多少毫秒：
user=> (time (reduce + (range 100))) 

"Elapsed time: 1.005 msecs" 

4950 

    就像我们之前提到的，这个测试宏在JVM上下文中几乎没什么意义。来个稍微好点的测试，测试一下在一个闭合循环中重复执行上万次计算：
user=> (time (dotimes `[i 100000`] 
               (reduce + (range 100)))) 
"Elapsed time: 252.594 msecs" 

nil 

    然而，这依然不能统观全貌，因为JVM可能在执行循环的过程中就对计算进行了优化。多次重复循环就能得到一个更加精确的结果：
user=> (dotimes [j 5] 
         (time (dotimes [i 100000] 
                 (reduce + (range 100))))) 
"Elapsed time: 355.759 msecs" 

"Elapsed time: 239.404 msecs" 

"Elapsed time: 217.362 msecs" 

"Elapsed time: 221.168 msecs" 

"Elapsed time: 217.753 msecs"

    如同你看到的那样，在这个例子中，数次迭代的执行时间基本上在220毫秒上下波动。这种模式就是JVM的特点。

    然而，即使拥有了这些信息，你仍然无法准确预期在一个大的应用上下文中，(reduce + (range 100))这个计算的性能如何。只能执行更多的测试来验证了。

    同样地，我们也得意识到延迟序列（lazy sequences）对于性能的影响。如果你用来测试的表达式采用了延迟序列（比如：map），time宏可能就只会给出初始化序列的时间。为了计算出获得整个序列的时间，你必须采用doall。但doall在复杂的数据结构中很难执行，而且获得的结果并不代表数据结构实际使用的性能。


*采用java性能工具*
------------------
    因为Clojure被编译成java字节码，java的性能工具同样可以在Clojure中使用，但是关于这些工具的讨论已经超出了这本书的讨论范围。

    最佳的经验法则如下：采用最直接、最简单的方式编写你的代码，然后测试看看是否达到预期性能。如果没有，采用性能工具去确定影响性能的关键点，然后迁移或者重写这些点上的代码直到满足你的性能需求。接下来的几页会描述一些分析性能关键点的技术。

*备忘*
------
    有一项能够加速大型复杂函数的简单技术叫做备忘（memoization），这是某种形式的缓存。当每次调用函数时，一个备忘函数会在table中储存被调函数的输入参数以及返回值。如果这个函数以同样的输入参数被再次调用时，它返回的就是储存在table中的值而不需要再次进行计算。

    Clojure内建支持备忘的函数是memoize，它接收一个函数做为参数，返回这个函数的备忘版本:
(defn really-slow-function `[x y z`] ...) 

(def faster-function (memoize really-slow-function)) 

    备忘是一个牺牲内存加速执行的经典例子。如果一个函数需要花费比哈希表寻址更多的时间去计算结果，而且它又经常以同样的输入参数被调用，那么采用备忘就是一种好的候选方案。只有纯函数－－意即针对特定输入总是返回同样结果的函数－－能够进行备忘。

    
*反射和类型提示*
----------------
    就像你所知的那样，java是种静态类型语言：它是在编译时确定所有对象的类型。而Clojure是动态类型，意即某些对象的类型一直要到运行时才会确定。

    要在静态类型的java上面实现动态类型的函数调用，Clojure采用了java的反射特性。反射允许代码在运行时查阅java的类并根据名字来调用方法。然而，通过反射调用方法比直接调用编译后的方法要慢上很多。

    Clojure允许你为符号和表达式加上类型提示以避免编译器通过反射调用方法。类型提示采用:tag关键字通过读取时元数据来进行声明。一个类型提示的symbol可以写成`#^{:tag hint} symbol，通常简写为`#^hint symbol。类型提示是一个java的类名。（这个类名会同样是个字符串，很少被需要去处理java费解的互用性问题）

    为了找出一个方法是反射调用还是不是，设置编译器属性**warn-on-reflection**为真，然后，执行代码，如果遇到反射调用，Clojure的编译器就会打印出一条警告信息。

user=> (set! **warn-on-reflection** true) 

true 

user=> (defn nth-char `[s n`] 
         (.charAt s n)) 

Reflection warning - call to charAt can't be resolved. 

    只要在调用的方法中对符号添加类型提示，这个警告通常就被消除掉了。对函数的参数或者采用let的本地绑定都有效果。

;; No reflection warnings: 

user=> (defn nth-char `[#^String s n`] 
         (.charAt s n)) 

#'user/nth-char 

user=> (defn nth-char `[s n`] 
         (let `[#^String st s`] 
(.charAt st n))) 

#'user/nth-char 

    在java方法采取不同类型参数重载的情况下，更增加了类型提示的必要性。举个例子，String.replace方法可以接收char 或者 CharSequence参数。你不得不在三个参数上都加类型提示来避免反射。

user=> (defn str-replace `[#^String s a b`] 
         (.replace s a b)) 

Reflection warning - call to replace can't be resolved. 

#'user/str-replace 

user=> (defn str-replace [#^String s 
                          #^CharSequence a 
                          #^CharSequence b] 
         (.replace s a b)) 

#'user/str-replace

    注意类型提示并非强制类型转换，它并不能把一种数据类型转换成另一种。采用错误的参数类型调用一个类型提示方法会抛出一个运行时错误：
user=> (str-replace "Hello" \H \J) 

java.lang.ClassCastException: java.lang.Character cannot be cast to java.lang.CharSequence 

    同样，注意一个不正确的提示类型会导致一个反射警告：
user=> (defn str-replace `[#^String s #^Integer a #^Integer b`] 
         (.replace s a b)) 

Reflection warning - call to replace can't be resolved. 

#'user/str-replace 

    你可以在函数定义时为Var加一个类型标记，为函数的返回值做类型提示。这在任何Var上都起作用，包括那些做为全局值使用的。

user=> (defn greeting `[`] "Hello, World!")  ;; no type hint 

#'user/greeting 

user=> (.length (greeting)) 

Reflection warning - reference to field length can't be resolved. 

13 

user=> (defn #^String greeting `[`] "Hello, World!") 

#'user/greeting 

user=> (.length (greeting))  ;; no reflection warning 

13 

user=> (defn greeting {:tag String} `[`] "Hello, World!") ;; same as above 

    在极少的情况下，符号的类型提示都无法有效地避免反射。在这样的情况下，你可以为整个表达式加上类型提示：
user=> (.length (identity "Hello, World!")) 

Reflection warning - reference to field length can't be resolved. 

13 

user=> (.length #^String (identity "Hello, World!")) 

13 

    Clojure的编译器在跟踪对象类型上面非常聪明。比如，java方法的返回类型总是能够被获知而无须类型提示。只要给予少少的提示，编译器就能够推演出大部分所需的其他类型信息。一般而言，你应该先写出没有任何类型提示的代码，然后打开*warn-on-reflection*参数，仅仅在需要提升性能的地方加上类型提示。

    
*使用基本类型*
--------------
    java的类型系统并非百分百地面向对象；它支持以下这些基本类型：boolean，char，byte,short，int，long，float和double。这些基本类型并不适合java的类体系，当方法中需要把基本类型做为对象使用时，就必须把它们装箱成 Boolean, Character, Byte, Short, Integer, Long, Float, 和Double类。从java1.5开始，java编译器就能够在需要时对基本类型进行自动装箱和拆箱。

    在Clojure中，一切都是对象，所以数字总是被装箱过的。这个可以在检查简单算术的结果时看到：
user=> (class (+ 1 1)) 

java.lang.Integer 

    然而，在JVM中，操作装箱的数字比不装箱的基本类型要来得慢。所以，在数学计算密集的应用中，采用装箱数字的Clojure代码要比直接采用基本类型的java代码要慢一些。

*循环中的基本类型*
------------------
    Clojure在循环体内支持基本类型。在loop或者let绑定的vector中，你可以采用boolean,char,byte,short,int,float和double这些函数来强制使用基本类型。这儿有个例子，是采用欧几里德的算法来计算两个整数的最大公分母：
(defn gcd `[a b`] 
  (loop `[a (int a), b (int b)`] 
    (cond (zero? a) b 
          (zero? b) a 
          (> a b) (recur (- a b) b) 
          :else (recur a (- b a))))) 