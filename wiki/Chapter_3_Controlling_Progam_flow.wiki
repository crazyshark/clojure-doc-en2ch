#Clojure程序流程控制.

= Clojure程序流程控制 =

==函数：==
 作为一个函数式编程语言，每一个Clojure 程序全是由函数组成。Clojure 的代码为树形结构，每一个函数作为一个树的节点分支出来，并调用其他函数。了解Clojure就意味着要了解它的函数和模式。如果粗心的编码你的程序很容易变得像碗杂酱面一样，混乱难懂。所以仔仔细细的编码才能使你的代码变得更快，更优雅，而你也将更享受的去写和读它们。

===一流的函数===
  在Clojure里，所有的函数都是一流的，意味着如下几条：
    # 可以在程序运行时的任何时刻被动态的创建加载；
    # 没有固定的命名，但是可以被绑定到若干个标识符；
    # 可以以任何数据结构进行存储；
    # 可以在函数之间被传递，传递到其他函数中进行运算；
相对而言其他静态语言的函数来说，比如Java、C。在这些语言中，函数总是需要在编译之前定义和命名。Clojure有这个极大的优势，包括其他的函数式编程语言，它们都可以在任何时刻定义一个新的函数，以及以任何数据结构进行存储。
===用fn定义函数===
	创建函数最基本的方式就是用fn专用语句块，在求值后返回一个新的函数。在最简单的块中，参数符号的集合（Vector 一个由方括号括起来的列表）以及函数体。
*note* ：Vector 由方括号括起来的集合，尚未讨论它，第四章有关于Vector其他特性的详细介绍，现在你可以先把它当成一个表达列表（list）的替换方式。不像列表（list）那样用圆括号括起来，求值时没有指向一个函数调用，所以它比较合适的去表达文本数据结构、没有多的函数调用，更快、更简单。

在REPL上的一个例子，你可以定义一个很简单的函数，提供两数相乘的功能。
{{{user=> (fn [x y] (* x y))}}}
 这个form可能看起来稍微复杂，但是它确实很简单：它只是另外三个form组成的：fn、`[x y]`、(`*` x y)。fn就是调用其他两个form的，`[x y]`是参数集合，说明这个新的函数有两个参数：x、y。(`*` x y)则是函数体，x、y分别绑定到各自的参数。`*`是乘法的运算符，Clojure的运算符都在前面。函数里面没有显示的“return”返回语句，因为函数总会返回表达式的求值结果。