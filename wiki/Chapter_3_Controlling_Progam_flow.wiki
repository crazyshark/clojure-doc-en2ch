#Clojure程序流程控制.

= Clojure程序流程控制 =

==函数：==
 作为一个函数式编程语言，每一个Clojure 程序全是由函数组成。Clojure 的代码为树形结构，每一个函数作为一个树的节点分支出来，并调用其他函数。了解Clojure就意味着要了解它的函数和模式。如果粗心的编码你的程序很容易变得像碗杂酱面一样，混乱难懂。所以仔仔细细的编码才能使你的代码变得更快，更优雅，而你也将更享受的去写和读它们。

===“一等公民” 函数===
  在Clojure里，所有的函数都是“一等公民”，一切都是基于函数的，意味着如下几条：
    # 可以在程序运行时的任何时刻被动态的创建加载；
    # 没有固定的命名，但是可以被绑定到若干个标识符；
    # 可以以任何数据结构进行存储；
    # 可以在函数之间被传递，传递到其他函数中进行运算；
相对而言其他静态语言的函数来说，比如Java、C。在这些语言中，函数总是需要在编译之前定义和命名。Clojure有这个极大的优势，包括其他的函数式编程语言，它们都可以在任何时刻定义一个新的函数，以及以任何数据结构进行存储。
===用fn定义函数===
	创建函数最基本的方式就是用fn专用语句块，在求值后返回一个新的函数。在最简单的块中，参数符号的集合（Vector 一个由方括号括起来的列表）以及函数体。
----
*note* ：Vector 由方括号括起来的集合，尚未讨论它，第四章有关于Vector其他特性的详细介绍，现在你可以先把它当成一个表达列表（list）的替换方式。不像列表（list）那样用圆括号括起来，求值时没有指向一个函数调用，所以它比较合适的去表达文本数据结构、没有多的函数调用，更快、更简单。
----
在REPL上的一个例子，你可以定义一个很简单的函数，提供两数相乘的功能。
{{{
user=> (fn [x y] (* x y))
}}}
 这个form可能看起来稍微复杂，但是它确实很简单：它只是另外三个form组成的：fn、`[x y]`、(`*` x y)。fn就是调用其他两个form的，`[x y]`是参数集合，说明这个新的函数有两个参数：x、y。(`*` x y)则是函数体，x、y分别绑定到各自的参数。`*`是乘法的运算符，Clojure的运算符都在前面。函数里面没有显示的“return”返回语句，因为函数总会返回表达式的求值结果。
然后而这是没多大用的，它只返回返回这个函数，而且这个函数也被转换成要在REPL中打印的字符串，这个字符串看起来完全没什么用。
{{{
#<user$eval__43$fn__45 user$eval__43$fn__45@ac06d4>
}}}
而且，这个函数你也现在也不能使用，因为你没有将这个函数绑定到任何标识符上面或者你没有将它存储在任何数据类型上。jvm可能立即会将它当垃圾回收了，因为它没有更多的使用。
典型的使用是要将它绑定到一个var上：
{{{
user=> (def my-mult (fn [x y] (* x y)))
}}}
现在你就可以在任何你有权限的上下文试用它了。
{{{
user=> (my-mult 3 4)
12
}}}