#Clojure程序流程控制.

= Clojure程序流程控制 =

==函数：==
 作为一个函数式编程语言，每一个Clojure 程序全是由函数组成。Clojure 的代码为树形结构，每一个函数作为一个树的节点分支出来，并调用其他函数。了解Clojure就意味着要了解它的函数和模式。如果粗心的编码你的程序很容易变得像碗杂酱面一样，混乱难懂。所以仔仔细细的编码才能使你的代码变得更快，更优雅，而你也将更享受的去写和读它们。

===“一等公民” 函数===
  在Clojure里，所有的函数都是“一等公民”，一切都是基于函数的，意味着如下几条：
    # 可以在程序运行时的任何时刻被动态的创建加载；
    # 没有固定的命名，但是可以被绑定到若干个标识符；
    # 可以以任何数据结构进行存储；
    # 可以在函数之间被传递，传递到其他函数中进行运算；
相对而言其他静态语言的函数来说，比如Java、C。在这些语言中，函数总是需要在编译之前定义和命名。Clojure有这个极大的优势，包括其他的函数式编程语言，它们都可以在任何时刻定义一个新的函数，以及以任何数据结构进行存储。

===用fn定义函数===
	创建函数最基本的方式就是用fn专用语句块，在求值后返回一个新的函数。在最简单的块中，参数符号的集合（Vector 一个由方括号括起来的列表）以及函数体。
----
*note* ：Vector 由方括号括起来的集合，尚未讨论它，第四章有关于Vector其他特性的详细介绍，现在你可以先把它当成一个表达列表（list）的替换方式。不像列表（list）那样用圆括号括起来，求值时没有指向一个函数调用，所以它比较合适的去表达文本数据结构、没有多的函数调用，更快、更简单。
----
在REPL上的一个例子，你可以定义一个很简单的函数，提供两数相乘的功能。
{{{
user=> (fn [x y] (* x y))
}}}
 这个form可能看起来稍微复杂，但是它确实很简单：它只是另外三个form组成的：fn、`[x y]`、(`*` x y)。fn就是调用其他两个form的，`[x y]`是参数集合，说明这个新的函数有两个参数：x、y。(`*` x y)则是函数体，x、y分别绑定到各自的参数。`*`是乘法的运算符，Clojure的运算符都在前面。函数里面没有显示的“return”返回语句，因为函数总会返回表达式的求值结果。
然后而这是没多大用的，它只返回返回这个函数，而且这个函数也被转换成要在REPL中打印的字符串，这个字符串看起来完全没什么用。
{{{
#<user$eval__43$fn__45 user$eval__43$fn__45@ac06d4>
}}}
而且，这个函数你也现在也不能使用，因为你没有将这个函数绑定到任何标识符上面或者你没有将它存储在任何数据类型上。jvm可能立即会将它当垃圾回收了，因为它没有更多的使用。
典型的使用是要将它绑定到一个var上：
{{{
user=> (def my-mult (fn [x y] (* x y)))
}}}
现在你就可以在任何你有权限的上下文使用它了。
{{{
user=> (my-mult 3 4)
12
}}}
而且，他的工作原理是公开的。表达式(fn [x y] (`*` x y))求出一个第一类对象函数，这个函数被绑定到my-mult上面。调用my-mult，你就可以用第一个元素“my-mult” 来执行函数求出一个list。“my-mult”当作这个新的函数，“3”和“4”被当作参数传入。

注意，将function分配到symbol不是唯一使用它的方式，只要将这个function放到一个form的第一个元素位置，对这个form求值的时候function就会被执行，不管这个function是不是绑定到一个symbol或者其他的东西上。举个例子，这个例子证明将function的定义和使用在同一个form里面是完全可行的：
{{{
user=> ((fn [x y] (* x y)) 3 4) 
12
}}}
在这个form里面，值得注意的是函数的定义(fn [x y] (`*` x y))放在form的第一个元素，
求值时(fn [x y] (`*` x y))被解析为一个function，“3 4”被当成参数传递给它。跟调用一个绑定了function的symbol一样。
总得来说跟js差不多。
这里要强调提醒一下，function与它绑定到的那个symbol是不能画等号的，在前面的例子，my-mult等于(fn [x y] (`*` x y))，只能理解为 (fn [x y] (`*` x y)) 绑定到my-mult这个符号上面。当它被调用时，通过解析它获得一个function然后接着去调用这个function。

===用defn定义函数===
尽管function与他们绑定的符号并不是同一个东西，但是通过绑定和命名函数是迄今为止使用函数最常见的方法。为此，Clojure提供了一个定义函数并绑定到符号的快捷方法：* defn *。
* defn *的字面意思是* def *和* fn *的合并，但是更简短、方便。它还提供了一个对函数添加文档字符串的功能，可以通过文档介绍这个函数如何使用。
* defn *接着往后的参数分别是：一个符号名，一个文档字符串（可选的），一个参数列表（vector），一个函数体的表达式（expression）。举个例子，下面的代码定义了一个函数，求一个参数的平方：
{{{
user=> (defn sq 
  "Squares the provided argument" 
  [x] 
         (* x x)) 
}}}
然后，你就可以使用制定的函数名来调用该函数：
{{{
user=> (sq 5) 
25 
}}}
你可以通过内置函数* doc *来查看函数的文档。系统输出会打印出该函数的文档信息。
{{{
user=> (doc sq) 
--------------------- 
user/sq 
([x]) 
   Squares the provided argument 
nil 
}}}
----
* tip *:* doc * 函数在编程的时候是非常有用的，Clojure所有的内置函数都有很好的文档（包括所有的类库），而且在* REPL *上使用* doc *函数也是相当方便的。同样，在你自己编写函数的时候也要养成给函数添加文档的习惯，及时没有其他人回来看你的代码，因为在一两周之后它对你自己的记忆也是有很大帮助的，让你正确的记得你当时定义这个函数是做什么的。
----
===多元函数===
元数是指函数的参数可以有多少组的组数，（类似与java的方法重载，调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法，多态性。）在Clojure中也可以基于元数来定义多个预备的实现。
这里同样使用* fn *和* defn *来定义函数，只是在参数上面有一些轻微的修改。之前是传递一个参数的vector和一个函数体的表达式（expression），现在要传递多个vector/expression对用圆括号括起来。下面代码比较好解释：
{{{
user=> (defn square-or-multiply 
         "squares a single argument, multiplies two arguments" 
        ([] 0) 
        ([x] (* x x)) 
        ([x y] (* x y))) 
}}}
这里定义的函数square-or-multiply有三个预定的实现。第一个的参数是一个空的vector，不传参数时被调用，返回常量0.第二个实现带了一个参数，返回该参数的平方值。第三个实现有两个参数，返回值为这两个参数的乘积。在REPL中验证：
{{{
user=> (square-or-multiply) 
0 
user=>(square-or-multiply 5) 
25 
user=>(square-or-multiply 5 2) 
10 
}}}