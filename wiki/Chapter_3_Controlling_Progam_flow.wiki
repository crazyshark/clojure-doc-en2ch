#Clojure程序流程控制.

= Clojure程序流程控制 =

==函数：==
 作为一个函数式编程语言，每一个Clojure 程序全是由函数组成。Clojure 的代码为树形结构，每一个函数作为一个树的节点分支出来，并调用其他函数。了解Clojure就意味着要了解它的函数和模式。如果粗心的编码你的程序很容易变得像碗杂酱面一样，混乱难懂。所以仔仔细细的编码才能使你的代码变得更快，更优雅，而你也将更享受的去写和读它们。

===“一等公民” 函数===
  在Clojure里，所有的函数都是“一等公民”，一切都是基于函数的，意味着如下几条：
    # 可以在程序运行时的任何时刻被动态的创建加载；
    # 没有固定的命名，但是可以被绑定到若干个标识符；
    # 可以以任何数据结构进行存储；
    # 可以在函数之间被传递，传递到其他函数中进行运算；
相对而言其他静态语言的函数来说，比如Java、C。在这些语言中，函数总是需要在编译之前定义和命名。Clojure有这个极大的优势，包括其他的函数式编程语言，它们都可以在任何时刻定义一个新的函数，以及以任何数据结构进行存储。

===用fn定义函数===
	创建函数最基本的方式就是用fn专用语句块，在求值后返回一个新的函数。在最简单的块中，参数符号的集合（Vector 一个由方括号括起来的列表）以及函数体。
----
*note* ：Vector 由方括号括起来的集合，尚未讨论它，第四章有关于Vector其他特性的详细介绍，现在你可以先把它当成一个表达列表（list）的替换方式。不像列表（list）那样用圆括号括起来，求值时没有指向一个函数调用，所以它比较合适的去表达文本数据结构、没有多的函数调用，更快、更简单。
----
在REPL上的一个例子，你可以定义一个很简单的函数，提供两数相乘的功能。
{{{
user=> (fn [x y] (* x y))
}}}
 这个form可能看起来稍微复杂，但是它确实很简单：它只是另外三个form组成的：fn、`[x y]`、(`*` x y)。fn就是调用其他两个form的，`[x y]`是参数集合，说明这个新的函数有两个参数：x、y。(`*` x y)则是函数体，x、y分别绑定到各自的参数。`*`是乘法的运算符，Clojure的运算符都在前面。函数里面没有显示的“return”返回语句，因为函数总会返回表达式的求值结果。
然后而这是没多大用的，它只返回返回这个函数，而且这个函数也被转换成要在REPL中打印的字符串，这个字符串看起来完全没什么用。
{{{
#<user$eval__43$fn__45 user$eval__43$fn__45@ac06d4>
}}}
而且，这个函数你也现在也不能使用，因为你没有将这个函数绑定到任何标识符上面或者你没有将它存储在任何数据类型上。jvm可能立即会将它当垃圾回收了，因为它没有更多的使用。
典型的使用是要将它绑定到一个var上：
{{{
user=> (def my-mult (fn [x y] (* x y)))
}}}
现在你就可以在任何你有权限的上下文使用它了。
{{{
user=> (my-mult 3 4)
12
}}}
而且，他的工作原理是公开的。表达式(fn `[x y]` (`*` x y))求出一个第一类对象函数，这个函数被绑定到my-mult上面。调用my-mult，你就可以用第一个元素“my-mult” 来执行函数求出一个list。“my-mult”当作这个新的函数，“3”和“4”被当作参数传入。

注意，将function分配到symbol不是唯一使用它的方式，只要将这个function放到一个form的第一个元素位置，对这个form求值的时候function就会被执行，不管这个function是不是绑定到一个symbol或者其他的东西上。举个例子，这个例子证明将function的定义和使用在同一个form里面是完全可行的：
{{{
user=> ((fn [x y] (* x y)) 3 4) 
12
}}}
在这个form里面，值得注意的是函数的定义(fn `[x y]` (`*` x y))放在form的第一个元素，
求值时(fn `[x y]` (`*` x y))被解析为一个function，“3 4”被当成参数传递给它。跟调用一个绑定了function的symbol一样。
总得来说跟js差不多。
这里要强调提醒一下，function与它绑定到的那个symbol是不能画等号的，在前面的例子，my-mult等于(fn `[x y]` (`*` x y))，只能理解为 (fn `[x y]` (`*` x y)) 绑定到my-mult这个符号上面。当它被调用时，通过解析它获得一个function然后接着去调用这个function。

===用defn定义函数===
尽管function与他们绑定的符号并不是同一个东西，但是通过绑定和命名函数是迄今为止使用函数最常见的方法。为此，Clojure提供了一个定义函数并绑定到符号的快捷方法：* defn *。
* defn *的字面意思是* def *和* fn *的合并，但是更简短、方便。它还提供了一个对函数添加文档字符串的功能，可以通过文档介绍这个函数如何使用。
* defn *接着往后的参数分别是：一个符号名，一个文档字符串（可选的），一个参数列表（vector），一个函数体的表达式（expression）。举个例子，下面的代码定义了一个函数，求一个参数的平方：
{{{
user=> (defn sq 
  "Squares the provided argument" 
  [x] 
         (* x x)) 
}}}
然后，你就可以使用制定的函数名来调用该函数：
{{{
user=> (sq 5) 
25 
}}}
你可以通过内置函数* doc *来查看函数的文档。系统输出会打印出该函数的文档信息。
{{{
user=> (doc sq) 
--------------------- 
user/sq 
([x]) 
   Squares the provided argument 
nil 
}}}
----
* tip *:* doc * 函数在编程的时候是非常有用的，Clojure所有的内置函数都有很好的文档（包括所有的类库），而且在* REPL *上使用* doc *函数也是相当方便的。同样，在你自己编写函数的时候也要养成给函数添加文档的习惯，及时没有其他人回来看你的代码，因为在一两周之后它对你自己的记忆也是有很大帮助的，让你正确的记得你当时定义这个函数是做什么的。
----
===多元函数===
元数是指函数的参数可以有多少组的组数，（类似与java的方法重载，调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法，多态性。）在Clojure中也可以基于元数来定义多个预备的实现。
这里同样使用* fn *和* defn *来定义函数，只是在参数上面有一些轻微的修改。之前是传递一个参数的vector和一个函数体的表达式（expression），现在要传递多个vector/expression对用圆括号括起来。下面代码比较好解释：
{{{
user=> (defn square-or-multiply 
         "squares a single argument, multiplies two arguments" 
        ([] 0) 
        ([x] (* x x)) 
        ([x y] (* x y))) 
}}}
这里定义的函数square-or-multiply有三个预定的实现。第一个的参数是一个空的vector，不传参数时被调用，返回常量0.第二个实现带了一个参数，返回该参数的平方值。第三个实现有两个参数，返回值为这两个参数的乘积。在REPL中验证：
{{{
user=> (square-or-multiply) 
0 
user=>(square-or-multiply 5) 
25 
user=>(square-or-multiply 5 2) 
10 
}}}
===可变参数函数===
经常需要一些函数的参数个数是不定的，被叫做可变参函数（variable arity）。Clojure满足了这个要求，通过定义函数时使用特殊符号`&` 放在参数vector里面实现。* fn *和* defn *都可以使用。
使用：定义参数vector时，只需将`&` 再加上一个符号名放在普通参数后面即可。函数调用时任何附加的参数都会被装在一个序列（seq，类似于list）的结构传递进去。然后这个序列将被绑定在参数列表`&`后面的那个符号上面。用下面的代码举个例子：
{{{
user=> (defn add-arg-count 
         "Returns the first argument + the number of additional arguments" 
        [first & more] 
        (+ first (count more))) 
}}}
* count *是一个简单的内置函数，它返回一个list的长度。查看运行结果：
{{{
user=> (add-arg-count 5) 
5 
user=> (add-arg-count 5 5) 
6 
user=> (add-arg-count 5 5 5 5 5 5) 
10 
}}}
第一次的调用，只有一个参数5，它被绑定到* first *上面而且有个空的list绑定到* more *上，因为没有附加的参数，'(count more)' 返回0。所以返回值也为第一个参数的值。然而，第二、三次调用时* more *分别绑定到了'(5)'和'(5 5 5 5 5)'上，长度分别为1和5，再加上第一个参数5并返回和。
第四章讨论了list以及一些通用函数来解析和求出他们的值。他们都能对绑定了list的* more *使用。
===快捷声明函数（Shorthand Function Declaration）===
用* fn *定义函数本来就很简洁，但是有时候完整输入的时候还是很麻烦的。特别是有时候只是内部声明一个函数，并没有绑定到全局变量上。
Clojure提供了一个定义函数的快捷形式，form里面有个一个阅读器宏（Reader macro）。用快捷方式定义一个函数：前面一个* # * 后面跟上一个表达式，这个表达式作为function的函数体。以及直接在这个表达式里面用百分号作为function的参数。
----
* note * Reader macros是专业的，通用的快捷语法。因为它在Clojure里面只有唯一的形式，没有被圆括号、中括号、花括号包起来。Clojure代码解析时最先解析他们，在代码编译之前把他们还原成正常形式。在编译器看来快捷形式的函数#(`*` `%`1 `%`2)等同于长形式的(fn `[x y]` (`*` x y))。阅读器宏提供了几个非常常见的任务，而且不能被用户自定义。此限制背后的理由是，读者宏的过度使用，使代码无法阅读，除非读者非常熟悉宏上面的问题。防止用户自定义阅读器宏有助于降低共享代码和保持Clojure语言一致性的难度。尽管如此，它还是对某些常见的form很有用的，所以Clojure默认提供了一个小的集合。
----
举个例子,下面是用shorthand的方式实现的一个求平方的函数：
{{{
user=> (def sq #(* % %)) 
#'user/sq 
user=> (sq 5) 
25 
}}}
这里的百分号意味着这个函数有一个参数，绑定到函数体中。如果定义多个参数的函数，只需在百分号后面加上1到20的数字即可：
{{{
user=> (def multiply #(* %1 %2)) 
'#user/multiply 
user=> (multiply 5 3) 
15 
}}}
* %1 * 或者* % *代表第一个参数，* %2 *代表第二个参数，以此类推。这样很容易看出快捷函数定义是多么的简洁，特别是内部函数：
{{{
user=> (#(* % %) 5) 
25 
}}}
==条件表达式（Conditional Expressions）==
任何编程语言都应该有在根据情况来改变程序流程的基本特性，Clojure当然也不例外，它提供了全套简单的条件形式。
最基本的条件形式是* if *语句，将一个判断表达式作为它的第一个参数进行求值。如果求值为true，那么就返回它的第二个参数（相当于“then”子句）的求值结果。如果结果为false（包括nil）就返回第三个参数的求值结果（相当于“else”子句），前提是有提供第三个参数并且不为空。用下面的代码举个例子：
{{{
user=> (if (= 1 1) 
     "Math still works.") 
"Math still works." 
}}}
另外一个例子执行else表达式：
{{{
user=> (if (= 1 2) 
     "Math is broken!" 
     "Math still works.") 
"Math still works." 
}}}
Clojure也提供了* if-not *语句。跟* if *的用法相同，但是作用是相反的。当逻辑为false的时候会去计算第二个参数的值，为true的时候才计算第三个参数的值。
{{{
user=> (if-not (= 1 1) 
     "Math is broken!" 
   "Math still works.") 
"Math still works." 
}}} 
有时候，逻辑不仅仅只有true和false，而有多个选项时。你可能会使用嵌套的* if *，但是这里有个更简洁的形式* cond *。* cond *可以有任意个“判断/表达式”对，作为它的参数。如果满足第一个判断，就执行第一个判断对应的表达式。如果没有满足第一个条件，就会尝试后面的判断表达式，以此类推。如果一个都没有满足，那么返回* nil *除非你用一个* :else *关键字放在最后来抓住剩下的所有可能性。举个例子，让我们用* cond *来定义一个评论天气的function：
{{{
(defn weather-judge 
"Given a temperature in degrees centigrade, comments on the weather." 
[temp] 
(cond 
    (< temp 20) "It's cold" 
    (> temp 25) "It's hot" 
:else  "It's comfortable")) 
}}}
用下面的代码试试：
{{{
user=> (weather-judge 15) 
"It's cold" 
user=> (weather-judge 22) 
"It's comfortable" 
user=> (weather-judge 30) 
"It's hot" 
}}}
----
* Tip *  * cond *本来是很有用，但是大量的使用它可能会导致代码难以维护，尤其是你程序中可能出现的情况在不断的增长。其实对这种情况的更优处理方式，用* multimethods *实现多态调用，更简单，扩展性更强。在第九章有详细的讲解。
----

==局部变量绑定==
在函数式编程语言中，新的值都是从嵌套多个函数调用的函数组合那儿获得的。但是有时为计算返回的值指派一个名称也是很有必要的，这样可以是代码更清晰，使其复用，提高效率。
Clojure提供了* let *形式可以达到这样的效果。* let *还允许你绑定多个变量，并将这些绑定的符号放到一个主体表达式中进行使用。这些符号的作用域也只能在* let *语句内，而且不可变，一旦这些符号被绑定整个* let *语句内得到的都是相同的值。
* let * 形式有一个包含了若干“名称-值”对的vector，以及一个主表达式，举个例子，下面的* let *表达式 将a绑定到2，b到3然后求它们的和：
{{{
user=> (let [a 2 b 3] (+ a b)) 
5 
}}}
这是最简单的方式使用* let *，然而，* let *会导致代码更琐碎，比起它提供的价值它更能带来复杂度。举一个更能引起注意的使用* let *的例子。考虑下面的代码：
{{{
(defn seconds-to-weeks 
"Converts seconds to weeks" 
[seconds] 
 (/ (/ (/ (/ seconds 60) 60) 24) 7)) 
}}}
它工作正常，但是读起来不是条理不是很清晰。嵌套的调用除法函数有些混乱。尽管大多数人不需太费心就能理解这些代码的意思。但是看起来简单的代码会少做更多的工作，并且，别人在也可以通过一些不是很熟悉的值和操作想象出类似的函数。函数要是写成这样也行永远也没有人能搞懂它。
我们可以使用* let *来让函数定义更清晰：
{{{
(defn seconds-to-weeks 
"Converts seconds to weeks" 
[seconds] 
(let [minutes (/ seconds 60) 
       hours (/ minutes 60) 
       days (/ hours 24) 
       weeks (/ days 7)] 
 weeks)) 
}}}
代码变长了，但是你可以清楚的知道每一个计算步骤都是干什么的，你将每一步的值都帮到一个中间符号，minutes、hours、days然后在返回weeks，而不是一气呵成的把整个计算合到一步完成，这个例子展示了一个通常的代码风格的选择。它使代码更清晰，也是代码变得更长了。什么时候，何时以及怎么使用都按照你自己的意愿。但是原则就是简单：* let *会使你的代码更清晰，而且将计算的返回值存到一个变量里面，可以增加代码的复用。

===循环和递归(Looping and Recursion)===
这对习惯于命令式编程语言的用户会有一些小小的冲击，因为Clojure没有提供直接的循环语法。然而，像其他函数式编程语言一样，它在遇到需要多次执行相同代码的情景时用递归来代替。因为Clojure鼓励使用不可变的数据结构，递归提供了一个更好的概念比典型的循环更适合，强制迭代。
从命令式编程语言进入函数式编程语言最大的挑战就是递归思想。但它却有令人惊讶的强大和优雅，而且你会很快的学会如何轻松的用递归来表达任何重复计算。
大多数程序员对递归都有个最简单的概念--那就是函数自己调用自己，虽然这个也不错，但是有关递归的作用，以及如何有效的使用它与它各个不同的场景是如何工作的都没有进行更深入的了解。
在Clojure（或者其他任何函数式编程语言，关于这一点）中有效的使用递归，只需将这些指南记住就可以了：
#使用一个递归函数的参数，来存储和修改计算进度。在命令式编程语言中，循环需要依赖重复修改一个变量。但是在Clojure中没有可以修改的变量。取而代之的是充分利用函数的参数，不要认为递归会重复修改任何东西。但是最为一个函数调用链，每次调用需要包含继续计算所需的所有信息。在一个递归计算过程中的任何值或修改结果应作为参数传递到下一个的递归函数调用，因此它就可以持续运行。
#确保递归有一个基本情况或基本条件。在每个递归函数中需要有个条件判断，如果某些目标或者判断条件已经达到或者满足，就得停止递归并返回结果。类似于命令式编程，防止无限循环。如果没有情况使代码停止，那它永远也不会停。显然，这会导致很多问题。
#每次迭代，递归都必须向目标条件靠近一步。否则，就不能保证它什么时候能结束。通常情况下，通过判断一些或大或小的数值是否达到某个临界值来作为基本条件。
举个例子，用牛顿算法来递归计算任何数的平方根。这个Clojure小程序有一个主函数以及几个辅助函数，展示了递归的功能。
_列表3-1计算平方根_
{{{
(defn abs 
    "Calculates the absolute value of a number" 
    [n] 
    (if (< n 0) 
        (* -1 n) 
        n)) 
 
(defn avg 
    "returns the average of two arguments" 
    [a b] 
    (/ (+ a b) 2)) 
 
(defn good-enough? 
    "Tests if a guess is close enough to the real square root" 
    [number guess] 
    (let [diff (- (* guess guess) number)] 
        (if (< (abs diff) 0.001) 
            true 
            false))) 
 
(defn sqrt 
    "returns the square root of the supplied number" 
    ([number] (sqrt number 1.0)) 
    ([number guess] 
    (if (good-enough? number guess) 
        guess 
        (sqrt number (avg guess (/ number guess)))))) 
}}}
让我们试试，将这个文件载入Clojure的运行环境后，然后在REPL中执行：
{{{
user=> (sqrt 25) 
5.000023178253949 
user=> (sqrt 10000) 
100.00000025490743 
}}}
众所周知，上面的代码返回一个数的平方根，精度在0.001以内。
前面三个函数不用过于追究，都是简单的辅助函数，除非你想去看看。重点在第四个函数* sqrt *上。