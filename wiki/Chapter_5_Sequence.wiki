#Start at Fri 14, Oct 2011
<wiki:toc max_depth="3" />

=什么是序列？=

在Clojure中，任何逻辑上可看做数据项集合（collection of items）的数据结构都可以使用序列这样一种统一的方式来读取，写入和修改。在非常基础的层次上，序列被整合进了Clojure，同时也是目前为止最为方便和符合规范的处理集合的方式。他们的角色等同于列表（lists）在其他Lisp方言中的角色。但是，序列不仅仅是一个操作集合的API(a collection API)，他们通常还作为框架（framework）以方便Clojure程序中流程和逻辑的构建，同时，简单易用的设计也使他们作为递归和高阶函数相关应用的基础。

从根本上来说，序列是一种抽象，将对所有集合的一些通用行为泛化喂一些通用的编程接口，然后将其通过一个由_序列函数_（_sequence functions_）组成的库（library）暴露出来以方便使用。基于对链接表（linked list）的一些经典的操作，例如“`first`”和“`rest`”，（或者“`car`”和“`cdr`”，对那些有lisp北京的人来说）的观察，我们设计出了序列，而且可以说序列在任何数据类型上都能工作的同样好。举个例子，`first`函数返回一个序列的第一个项（item）。无论这个序列实际上是一个list，vector（向量），set，或者甚至是一个map（键值对），都没有任何区别。

<code language="clj">
user=> (def mylist '(1 2 3))
user=> (first mylist)
1

 user=> (def myvec [1 2 3])
user=> (first myvec)
1

 user=> (def myset #{1 2 3})
user=> (first myset)
1

 user=> (def mymap {:a 1 :b 2 :c 3})
user=> (first mymap)
[:a 1}
</code>

相似的，`rest`函数对于任何序列返回剔除了第一个项的一个新的序列：

<code language="clj">
user=> (def mylist '(1 2 3))
user=> (rest mylist)
(2 3)
</code>

序列函数是非常有用的。举个例子，只需要`first`和`rest`（还需要另一个函数，`empty?`，如果一个序列为空则放回true）就能实现一个Lisp中极为常见的惯用语：递归遍历一个list的函数。但是，因为你使用的是序列，除了list，你可以遍历任何数据集合。

<code language="clj">
(defn printall `[s]`

    (if (not (empty? s))
        (do
            (println (str "Item: " (first s)))
            (recur (rest s)))))
</code>

这个函数以一个序列作为输入参数，并建厂这个序列是否为空。如果为空，这个函数什么都不做（隐式返回nil）。如果序列中含有项，它就以副作用（side effect）的形式将字符串“Item:”与序列中第一项连接并打印出来。然后函数递归，将序列中剩下的项传入下一个迭代中。函数可以以list为输入参数：

<code language="clj">
user=> (printall '(1 2 3))
Item: 1
Item: 2
Item: 3
nil
</code>

或者是vector：
<code language="clj">
user=> (printall ["vector" "of" "strings"])
Item: vector
Item: of
Item: strings
nil
</code>

甚至是字符串也行得通，因为字符串可以看做是字符的序列：
<code language="clj">
user=> (printall " Hello")
Item: H
Item: e
Item: l
Item: l
Item: o
nil
</code>

正是因为序列是如此的泛化，同一个函数可以在所有这些完全不同的集合类型上表现如此完美。

----

*注意* 从技术的角度讲，这些不同类型的数据结构本身并不是序列，而是可以通过使用`seq`转化为序列。函数`seq`以蛋哥参数作为输入，为其构造一个序列视图。比如，向量并非序列，但是`(seq any-vector)`的结果却是一个序列。因为几乎所有的序列函数都在内部隐含的调用了`seq`，所以在大多数实际应用的时候，是否使用一个序列作为参数并没有太大的差别。但是，有一个地方需要注意，如果你碰到一个需要序列，而不是一个可序列化（sequence-able）的集合作为参数的函数：这里就有一些差别了。你可以使用`seq`在任何collection之上高效地获取一个序列视图。

----

==可序列化的类型==

序列几乎可以从任何语言支持的collection类型上创建。

 * Clojure的持久化集合：Maps，sets， lists， 以及vectors都能作为序列很好地工作。
 * 字符串：所有字符串都是字符的序列。
 * Java数组：但是这可能会造成匹配不当，因为Java数组是可变的，而序列不会试着去避免复杂的故障（difficult bugs）。当你使用一个构建在数组之上的序列的时候，试着避免去修改这个数组
 * 任何实现了java.lang.Iterable接口的Java collection。同样的，相对于序列的不可变，Java collection是可变的，所以在使用的时候应当避免去修改collections。
 * 本地支持：序列也可以不需要任何其他collection类型的支持而直接构造。

=解析序列=