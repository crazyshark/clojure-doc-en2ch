#Start at Fri 14, Oct 2011
<wiki:toc max_depth="3" />

=什么是序列？=

在Clojure中，任何逻辑上可看做数据项集合（collection of items）的数据结构都可以使用序列这样一种统一的方式来读取，写入和修改。在非常基础的层次上，序列被整合进了Clojure，同时也是目前为止最为方便和符合规范的处理集合的方式。他们的角色等同于列表（lists）在其他Lisp方言中的角色。但是，序列不仅仅是一个操作集合的API(a collection API)，他们通常还作为框架（framework）以方便Clojure程序中流程和逻辑的构建，同时，简单易用的设计也使他们作为递归和高阶函数相关应用的基础。

从根本上来说，序列是一种抽象，将对所有集合的一些通用行为泛化喂一些通用的编程接口，然后将其通过一个由序列函数（sequence functions）组成的库（library）暴露出来以方便使用。基于对链接表（linked list）的一些经典的操作，例如“`first`”和“`rest`”，（或者“`car`”和“`cdr`”，对那些有lisp背景的人来说）的观察，我们设计出了序列，而且可以说序列在任何数据类型上都能工作的同样好。举个例子，`first`函数返回一个序列的第一个项（item）。无论这个序列实际上是一个list，vector（向量），set，或者甚至是一个map（键值对），都没有任何区别。

<code language="clj">
user=> (def mylist '(1 2 3))
user=> (first mylist)
1

 user=> (def myvec [1 2 3])
user=> (first myvec)
1

 user=> (def myset #{1 2 3})
user=> (first myset)
1

 user=> (def mymap {:a 1 :b 2 :c 3})
user=> (first mymap)
[:a 1}
</code>

相似的，`rest`函数对于任何序列返回剔除了第一个项的一个新的序列：

<code language="clj">
user=> (def mylist '(1 2 3))
user=> (rest mylist)
(2 3)
</code>

序列函数是非常有用的。举个例子，只需要`first`和`rest`（还需要另一个函数，`empty?`，如果一个序列为空则放回true）就能实现一个Lisp中极为常见的惯用语：递归遍历一个list的函数。但是，因为你使用的是序列，除了list，你可以遍历任何数据集合。

<code language="clj">
(defn printall `[s]`

    (if (not (empty? s))
        (do
            (println (str "Item: " (first s)))
            (recur (rest s)))))
</code>

这个函数以一个序列作为输入参数，并建厂这个序列是否为空。如果为空，这个函数什么都不做（隐式返回nil）。如果序列中含有项，它就以副作用（side effect）的形式将字符串“Item:”与序列中第一项连接并打印出来。然后函数递归，将序列中剩下的项传入下一个迭代中。函数可以以list为输入参数：

<code language="clj">
user=> (printall '(1 2 3))
Item: 1
Item: 2
Item: 3
nil
</code>

或者是vector：
<code language="clj">
user=> (printall ["vector" "of" "strings"])
Item: vector
Item: of
Item: strings
nil
</code>

甚至是字符串也行得通，因为字符串可以看做是字符的序列：
<code language="clj">
user=> (printall " Hello")
Item: H
Item: e
Item: l
Item: l
Item: o
nil
</code>

正是因为序列是如此的泛化，同一个函数可以在所有这些完全不同的集合类型上表现如此完美。

----

*注意* 从技术的角度讲，这些不同类型的数据结构本身并不是序列，而是可以通过使用`seq`转化为序列。函数`seq`以蛋哥参数作为输入，为其构造一个序列视图。比如，向量并非序列，但是`(seq any-vector)`的结果却是一个序列。因为几乎所有的序列函数都在内部隐含的调用了`seq`，所以在大多数实际应用的时候，是否使用一个序列作为参数并没有太大的差别。但是，有一个地方需要注意，如果你碰到一个需要序列，而不是一个可序列化（sequence-able）的集合作为参数的函数：这里就有一些差别了。你可以使用`seq`在任何collection之上高效地获取一个序列视图。

----

==可序列化的类型==

序列几乎可以从任何语言支持的collection类型上创建。

 * Clojure的持久化集合：Maps，sets， lists， 以及vectors都能作为序列很好地工作。
 * 字符串：所有字符串都是字符的序列。
 * Java数组：但是这可能会造成匹配不当，因为Java数组是可变的，而序列不会试着去避免复杂的故障（difficult bugs）。当你使用一个构建在数组之上的序列的时候，试着避免去修改这个数组
 * 任何实现了java.lang.Iterable接口的Java collection。同样的，相对于序列的不可变，Java collection是可变的，所以在使用的时候应当避免去修改collections。
 * 本地支持：序列也可以不需要任何其他collection类型的支持而直接构造。

=剖析序列=

理解序列的底层逻辑结构是非常重要的。以不同方式构造的序列在实现上有很大程度的差异。一个vector的序列表示，起本质上依旧是一个vector，拥有和vector一样的性能特性（performance characteristics）。但是所有的序列共享一个相同的概念模型：根据`first`和`rest`实现的一个单向链接（singly-linked）list。顺便说一句，`first`和`rest`和传统Lisp中的`car`和`cdr`是完全相同的。他们以便现代程序员更为熟悉的属于被重命名，同时也更为准确的表现了他们的意图。

每个序列，从概念上讲，都是有两个部分组成：使用`first`函数访问的序列中的第一个项，即`first`部分，以及使用`rest`函数访问的序列中所有其他剩下的项，即`rest`部分。每个包含n项的序列序列实际上都有n-1个组件序列（component sequences）组合而成。序列在`rest`返回为空的时候终结。所有其他的序列函数都可以根据`first`和`rest`来定义，虽然从collection类型创建的序列为了获得更好的性能直接实现了他们（指其他的序列函数）。

图5-1 序列示例，展示组件序列

=构建序列=

使用这样的序列模型，使用`cons`或者`conj`两个函数来直接构建序列都是相当容易的。`cons`函数意为“构件（construct）”，它需要两个参数作为输入，一个项和一个序列。它使用这个项作为第一项（first），这个序列作为所有剩下的项（rest）构件一个新的序列。一个由`cons`构建的序列被称为“构建单元（cons cell）”——一个简单的first/rest对。任何长度的序列都可以通过将多个构件单元链接的方式来构建。

<code language="clj">
user=> (cons 4 '(1 2 3))
(4 1 2 3)
</code>

`conj`函数与`cons`函数相似，表示“联合（conjoin）”。它与`cons`的最主要的区别是（如果可能的话）它会重用序列的底层实现而不是总去构建“构建单元”。这样做通常会使得到的序列工作更为高效。新的项是添加到序列的最前端还是最后段是更具序列的底层实现来决定的。不同于`cons`，`conj`使用一个序列作为它的第一个输入参数，将要添加的项反而作为第二个参数：

<code language="clj">
user=> (conj '(1 2 3) 4)
(4 1 2 3)
</code>

`conj`也支持一次性添加多个项：只需要是用多个附加参数即可。序列按他们提供的顺序被添加到序列的前端：

<code language="clj">
user=> (conj '(1 2 3) 4 5 6)
(6 5 4 1 2 3)
</code>

----

*注意* `conj`的一个特性需要留意一下，它在内部并不会在它的输入参数上调用`seq`。它也可以直接工作在数据结构（data structures）上，与工作在序列之上没有任何差别。在这种情况下，它会根据特定数据结构将新的项以最高效的方式添加，而不是必须将其添加到最前方（它对序列是这样做的）。就拿vector来说，添加项最为高效的地方是vector的最末端。所以`(conj [1 2] 3)`将会得到`[3 1 2]`。如果你知道你需要一个序列，而且你也希望将项添加到最前方，在vector上调用`seq`：`(conj (seq [1 2]) 3)`将得到你想要的`(3 1 2)`。你也可以使用`cons`来代替。在不想将你的collection类型转化为序列的时候去使用`conj`。

----

对于`conj`和`cons`，如果你在需要序列作为输入的地方填入了nil，它会构建一个仅包含你提供的那个项的序列。

<code language="clj">
user=> (cons 1 nil)
(1)
</code>

接下来是另一个很常见的Lisp惯用法，使用`cons`或者`conj`来递归地构建一个list。下面的这个函数展示了使用从1到用户输入的参数之间的所有整数来递归构造的一个序列：

<code language="clj">
(defn make-int-seq `[max]`

     (loop `[acc nil n max]`

          (if (zero? n)
          acc
          (recur (cons n acc) (dec n)))))
</code>

在每次迭代中，这个函数将n（初始为最大值）用`cons`函数添加到一个累加器（accumulator）序列（初始化为nil）中，然后递归，将新的累加器和新的被减一（decremented）的n传入。当n累减直0之后，函数将这个累加器序列返回，这时它已经包含了所有1到最大值。

<code language="clj">
user=> (make-int-seq 5)
(1 2 3 4 5)
</code>

=延迟加载的序列=

延迟加载（laziness，等同于惰性），Clojure中序列另一个极为重要的方面，是以first/rest结构为基础的。延迟加载为操作那些数据量太大以至于无法一次加载到系统内存的数据提供了一种概念上十分简单，同时也相当搞笑的方式。这些数据可以具有无穷的长度，却依旧可以被任意标准序列函数高效地使用。延迟加载的序列作为一种高阶抽象，它是开发者能够专注于那些正在进行的计算，而不是去管理加载和创造数据的繁琐细节。

延迟加载这种概念是根据这样一个观察和研究得到的：逻辑上讲，一个序列的`rest`部分实际上并不是必须存在的，只要可以在需要的时候创建就行了。延迟加载序列的`rest`部分可以被实现为返回一个序列的函数，而不是包含一个实际的明确的一系列值。从使用这个序列的函数来看，这并没有什么差别；当他们调用`rest`函数的时候，他们得到了一个序列。不同仅仅在于如果是一个一般的序列，它会返回一个已经存在与内存中的数据结构。在延迟加载序列中，调用`rest`实际上计算并初始化了一个新的序列，这个序列使用刚刚计算出来的值作为它的`first`，使用一系列有关如何生成更多的值的指令（一系列代码）作为它的`rest`。

考虑到效率问题，一旦延迟加载的序列被实现（realize），得到的值将被作为正常的非延迟加载的序列缓存下来——之后对这个序列的访问将会以正常的方式访问，而不是被延迟地产生。这样保证了延迟加载所需的计算只会被运行一次：在延迟加载的时候使用大量的，沉重繁复的的计算将不会导致任何的性能问题，因为这种机制保证了它们只会运行一次。只要有代码在使用这些缓存的值，它们就会一直存在。当没有任何引用存在的时，这些缓存的值会像其他所有对象一样被作为垃圾回收。

==一个延迟加载的例子==

想要看看延迟加载序列如何工作，可以想想`map`函数。`map`函数是Clojure中一个极为重要的序列操作工具。它需要一个序列和一个函数作为输入参数，它将这个函数应用到所提供序列中每一项，根据返回值得到一个新的序列。举个例子，如果你将序列`'(1 2 3 4 5 6 7)`和一个将参数平方的函数，`(fn [x] (*x x))`传入`map`，它的返回值则为`(1 4 9 16 25 36 49)`。这就是将所有原序列中的项平方之后得到的结果。

<code language="clj">
user => (map
                (fn `[x] (* x x))`

                '(1 2 3 4 5 6 7))
(1 4 9 16 25 36 49)
</code>

`map`的返回值实际上是一个延迟加载的序列，看到这一点并不是那么容易。因为返回值是立即就输出到了REPL中，差别几乎是看不到的——实际的值立刻就被实现了。

为了看到延迟加载序列的内部工作情况，让我们向你的平方方程添加一点附带的功能（side effect），这样你就能看到运算是什么时候发生的（一般来说，在传递给`map`的函数中添加副作用不是一个好的设计实践，但是在这里这样做能展示延迟加载的一些细节）。在新的平方函数中，你会在每个参数的值被处理的时候将其打印出来。让我们把事情简化一点，用`defn`而不是以内联的形式将这个新函数传递给`map`：

<code language="clj">
(defn square `[x]`

    (do
      (println (str "Processing: " x))
      (* x x)))
</code>

除了用`do`来实现一点副作用，将参数的值在被处理之前给打印出来，这个函数跟它的上一个版本完全是一样的。它返回一个比较出人意料而且有点混乱的结果：

<code language="clj">
user => (map square '(1 2 3 4 5)
(Processing:1
Processing:2
1 Processing:3
4 Processing:4
9 Processing:5
16 25)
</code>

结果如此难看的原因是`println`在打印输出结果的过程中被调用。包含`println`调用的平方函数知道它真正被需要的时候才会被调用——知道系统真的需要实现这个延迟加载的值得时候。所以你的这些`println`调试语句和函数的实际输出：“（1 4 9 16 25）”完全搀和在了一起。

为了让事情更为清除，让我们对`map`的调用结果赋值给一个符号（symbol）：

<code language="clj">
user =>(def map-result (map square '(1 2 3 4 5))
#'user/map-result
</code>

你现在有了一个符号，按理说，应该是绑定到一个由平方值组成的序列。但是，你没有看到你的调试语句。`square`完全没有被调用！`map-result`是一个延迟加载的序列。所以，逻辑上讲它包含了你想要的那些平方值，但是他们还没有被实现。所以它并不是一个平方值的序列，而是一个平方值序列的承诺（promise）。你可以把它传递到程序的任何地方，或者把它存储起来，实际的运算工作会等到真正需要的时候再进行。

现在，让我们使用`nth`函数来获取序列的几个值。`nth`函数可以根据输入参数获取序列某个位置的值。调用`(nth map-result 2)`应该返回9，因为3的平方值是9，同时3是原序列中第二个(2nd)个项（从0开始，因为Clojure中所有的索引都是从0开始的）。

<code language="clj">
user => (nth map-result 2)
Processing:1
Processing:2
Processing:3
9
</code>

你可以从调试语句中发现函数`square`被调用了三次——刚好足够来计算序列中第三个值。但是，再次运行相同的函数调用不会再触发`square`函数了：

<code language="clj">
user => (nth map-result 2)
9
</code>

实现的值已经被缓存了，所以没有必要再次调用`square`去计算他们。现在，打印出序列的所有值：

<code language="clj">
user => (println map-result)
(1 4 Processing:4
9 Processing:5
16 25)
</code>

只调用了`square`两次，只是为了计算序列中两个剩下的还未实现的值。缓存的值并未重新计算。

这个例子展示了`map`函数返回的延迟加载序列是如何将实际运算推迟到这些值真正需要的时候再进行。

==构建延迟加载的序列==

获取一个延迟加载序列是相当简单的。大多数Clojure的内置序列函数，诸如`map`和`filter`都默认返回延迟加载的序列。如果你想要生成你自己的延迟加载序列，有两种方法可以实现：直接构造一个，或者使用一个生成延迟加载序列的函数来帮你。

===直接构造延迟加载的序列===

想要手动构建延迟加载的序列，可以使用内建的`lazy-seq`宏，将原本会返回一般的非延迟加载序列的代码给包装起来。`lazy-seq`将任何它包装的代码所返回的值延迟化，从而构建一个延迟加载的序列。这些代码不会理解执行，而是被放到延迟加载序列的上下文中留到以后执行（saved for later）。

举个例子，下面这个函数通过设置一个基准值，然后不断地把另一个数值加给它，以构造一个延迟加载序列。

<code language="clj">
(defn lazy-counter `[base increment]`

     (lazy-seq
          (cons base (lazy-counter (+ base increment) increment))))
</code>

然后，你就可以调用这个函数，并使用`take`函数来获取延迟加载序列的开始几个值。（`take`有两个输入参数，一个整数和一个集合。它从这个集合中获取指定的项，返回由这些项组成的序列）

<code language="clj">
user=> (take 10 (lazy-counter 0 2))
(0 2 4 6 8 10 12 14 16 18)
</code>

这个序列从逻辑上说，真的是无限长的。打个比方，从2开始，每次加3，使用`nth`来获取第一百万个项：

<code language="clj">
user=> (nth (lazy-counter 2 3) 1000000)
3000002
</code>

因为是无限长的，你可以用`lazy-counter`来获取一个任意长度的序列——唯一的限制会变成你的电脑会花多少时间去将一百万个、十亿个或者是任何你选择的数量的数字加在一起。

可以把它跟非延迟加载的版本比较一下：

<code language="clj">
(defn counter `[base increment]`

(cons base (counter (+ base increment) increment)))
</code>

这个函数甚至还没开始真正运行就失败了。它几乎立即就在`StackOverflowError`面前倒下了。因为它没有推迟任何运算，它总是立即选择递归直至将JVM中的栈空间耗尽。延迟加载的版本不会有这个问题。虽然它也是以递归的方式定义的，但是，只有当处理延迟加载学列的内部代码准备好展开下一个值得时候，`lazy-seq`中包含的内容才会被执行。这样做不会消耗栈空间，所以延迟加载序列可以做到即十分高效，又能在逻辑上达到长度无限。

----

*注意* 在处理无限长序列的时候需要特别注意。他们在逻辑上是无限长的，但是要注意别去尝试实现（展开）无穷多的值。比如，试着去在REPL中直接答应一个无限长的延迟加载序列，如果你没有使用`take`或相类似的函数，程序会在延迟加载序列上大量产生数值，直到无穷永不停止，最后被锁住。在这种或是其他相类似的情景中，写出不停去处理一个无限长序列，并最终将所在的线程完全锁住的代码是完全有可能的。无限长的序列能够十分有用，但是一定要确定在使用它们的时候设定了合适的结束条件，而不是依赖于达到序列的结尾处。仅仅因为序列是无限长的不代表你要花费无穷多的时间去处理它，或者试着一次将所有的东西都加在到内存中。很可惜，电脑是能力有限的机器，经不起这样折腾。

----

===使用序列产生函数来构造延迟加载序列===

许多需要延迟加载序列的常见情况中，使用序列产生函数（sequence generator function）通常会比直接使用`lazy-seq`更为简便。`iterate`函数就是特别有用的。它通过将序列中之前的一个项作为输入参数调用提供的函数，把得到的值作为下一个项，以产生一个无限长的序列。它需要两个输入参数：用来调用的函数和序列中第一个项。

比如，把`iterate`和内建的递增函数`inc`联合起来生成一个所有整数组成的无限长延迟加载序列：

<code language="clj">
user=> (def integers (iterate inc 0))
#'user/integers
user=> (take 10 integers)
(0 1 2 3 4 5 6 7 8 9)
</code>

通过提供一个特定的函数，`iterate`可以用来提供与之前提到的`lazy-counter`函数完全相同的功能：

<code language="clj">
(defn lazy-counter-iterate `[base increment]`

           (iterate (fn [n] (+ n increment)) base))
user=> (nth (lazy-counter-iterate 2 3) 1000000)
3000002
</code>

还有几个与`iterate`功能相似的函数：请查看[Chapter_5_Sequence#序列API]章节。

===延迟加载序列和内存管理===



=序列API=