#Start at Fri 14, Oct 2011
<wiki:toc max_depth="3" />

=什么是序列？=

在Clojure中，任何逻辑上可看做数据项集合（collection of items）的数据结构都可以使用序列这样一种统一的方式来读取，写入和修改。在非常基础的层次上，序列被整合进了Clojure，同时也是目前为止最为方便和符合规范的处理集合的方式。他们的角色等同于列表（lists）在其他Lisp方言中的角色。但是，序列不仅仅是一个操作集合的API(a collection API)，他们通常还作为框架（framework）以方便Clojure程序中流程和逻辑的构建，同时，简单易用的设计也使他们作为递归和高阶函数相关应用的基础。

从根本上来说，序列是一种抽象，将对所有集合的一些通用行为泛化喂一些通用的编程接口，然后将其通过一个由序列函数（sequence functions）组成的库（library）暴露出来以方便使用。基于对链接表（linked list）的一些经典的操作，例如“`first`”和“`rest`”，（或者“`car`”和“`cdr`”，对那些有lisp北京的人来说）的观察，我们设计出了序列，而且可以说序列在任何数据类型上都能工作的同样好。举个例子，`first`函数返回一个序列的第一个项（item）。无论这个序列实际上是一个list，vector（向量），set，或者甚至是一个map（键值对），都没有任何区别。

<code language="clj">
user=> (def mylist '(1 2 3))
user=> (first mylist)
1

 user=> (def myvec [1 2 3])
user=> (first myvec)
1

 user=> (def myset #{1 2 3})
user=> (first myset)
1

 user=> (def mymap {:a 1 :b 2 :c 3})
user=> (first mymap)
[:a 1}
</code>

相似的，`rest`函数对于任何序列返回剔除了第一个项的一个新的序列：

<code language="clj">
user=> (def mylist '(1 2 3))
user=> (rest mylist)
(2 3)
</code>

序列函数是非常有用的。举个例子，只需要`first`和`rest`（还需要另一个函数，`empty?`，如果一个序列为空则放回true）就能实现一个Lisp中极为常见的惯用语：递归遍历一个list的函数。但是，因为你使用的是序列，除了list，你可以遍历任何数据集合。

<code language="clj">
(defn printall `[s]`

    (if (not (empty? s))
        (do
            (println (str "Item: " (first s)))
            (recur (rest s)))))
</code>

这个函数以一个序列作为输入参数，并建厂这个序列是否为空。如果为空，这个函数什么都不做（隐式返回nil）。如果序列中含有项，它就以副作用（side effect）的形式将字符串“Item:”与序列中第一项连接并打印出来。然后函数递归，将序列中剩下的项传入下一个迭代中。函数可以以list为输入参数：

<code language="clj">
user=> (printall '(1 2 3))
Item: 1
Item: 2
Item: 3
nil
</code>

或者是vector：
<code language="clj">
user=> (printall ["vector" "of" "strings"])
Item: vector
Item: of
Item: strings
nil
</code>

甚至是字符串也行得通，因为字符串可以看做是字符的序列：
<code language="clj">
user=> (printall " Hello")
Item: H
Item: e
Item: l
Item: l
Item: o
nil
</code>

正是因为序列是如此的泛化，同一个函数可以在所有这些完全不同的集合类型上表现如此完美。

----

*注意* 从技术的角度讲，这些不同类型的数据结构本身并不是序列，而是可以通过使用`seq`转化为序列。函数`seq`以蛋哥参数作为输入，为其构造一个序列视图。比如，向量并非序列，但是`(seq any-vector)`的结果却是一个序列。因为几乎所有的序列函数都在内部隐含的调用了`seq`，所以在大多数实际应用的时候，是否使用一个序列作为参数并没有太大的差别。但是，有一个地方需要注意，如果你碰到一个需要序列，而不是一个可序列化（sequence-able）的集合作为参数的函数：这里就有一些差别了。你可以使用`seq`在任何collection之上高效地获取一个序列视图。

----

==可序列化的类型==

序列几乎可以从任何语言支持的collection类型上创建。

 * Clojure的持久化集合：Maps，sets， lists， 以及vectors都能作为序列很好地工作。
 * 字符串：所有字符串都是字符的序列。
 * Java数组：但是这可能会造成匹配不当，因为Java数组是可变的，而序列不会试着去避免复杂的故障（difficult bugs）。当你使用一个构建在数组之上的序列的时候，试着避免去修改这个数组
 * 任何实现了java.lang.Iterable接口的Java collection。同样的，相对于序列的不可变，Java collection是可变的，所以在使用的时候应当避免去修改collections。
 * 本地支持：序列也可以不需要任何其他collection类型的支持而直接构造。

=剖析序列=

理解序列的底层逻辑结构是非常重要的。以不同方式构造的序列在实现上有很大程度的差异。一个vector的序列表示，起本质上依旧是一个vector，拥有和vector一样的性能特性（performance characteristics）。但是所有的序列共享一个相同的概念模型：根据`first`和`rest`实现的一个单向链接（singly-linked）list。顺便说一句，`first`和`rest`和传统Lisp中的`car`和`cdr`是完全相同的。他们以便现代程序员更为熟悉的属于被重命名，同时也更为准确的表现了他们的意图。

每个序列，从概念上讲，都是有两个部分组成：使用`first`函数访问的序列中的第一个项，即`first`部分，以及使用`rest`函数访问的序列中所有其他剩下的项，即`rest`部分。每个包含n项的序列序列实际上都有n-1个组件序列（component sequences）组合而成。序列在`rest`返回为空的时候终结。所有其他的序列函数都可以根据`first`和`rest`来定义，虽然从collection类型创建的序列为了获得更好的性能直接实现了他们（指其他的序列函数）。

图5-1 序列示例，展示组件序列

=构建序列=

使用这样的序列模型，使用`cons`或者`conj`两个函数来直接构建序列都是相当容易的。`cons`函数意为“构件（construct）”，它需要两个参数作为输入，一个项和一个序列。它使用这个项作为第一项（first），这个序列作为所有剩下的项（rest）构件一个新的序列。一个由`cons`构建的序列被称为“构建单元（cons cell）”——一个简单的first/rest对。任何长度的序列都可以通过将多个构件单元链接的方式来构建。

<code language="clj">
user=> (cons 4 '(1 2 3))
(4 1 2 3)
</code>

`conj`函数与`cons`函数相似，表示“联合（conjoin）”。它与`cons`的最主要的区别是（如果可能的话）它会重用序列的底层实现而不是总去构建“构建单元”。这样做通常会使得到的序列工作更为高效。新的项是添加到序列的最前端还是最后段是更具序列的底层实现来决定的。不同于`cons`，`conj`使用一个序列作为它的第一个输入参数，将要添加的项反而作为第二个参数：

<code language="clj">
user=> (conj '(1 2 3) 4)
(4 1 2 3)
</code>

`conj`也支持一次性添加多个项：只需要是用多个附加参数即可。序列按他们提供的顺序被添加到序列的前端：

<code language="clj">
user=> (conj '(1 2 3) 4 5 6)
(6 5 4 1 2 3)
</code>

----

*注意* `conj`的一个特性需要留意一下，它在内部并不会在它的输入参数上调用`seq`。它也可以直接工作在数据结构（data structures）上，与工作在序列之上没有任何差别。在这种情况下，它会根据特定数据结构将新的项以最高效的方式添加，而不是必须将其添加到最前方（它对序列是这样做的）。就拿vector来说，添加项最为高效的地方是vector的最末端。所以`(conj [1 2] 3)`将会得到[3 1 2]。如果你知道你需要一个序列，而且你也希望将项添加到最前方，在vector上调用`seq`：`(conj (seq [1 2]) 3)`将得到你想要的`(3 1 2)`。你也可以使用`cons`来代替。在不想将你的collection类型转化为序列的时候去使用`conj`。

----

对于`conj`和`cons`，如果你在需要序列作为输入的地方填入了nil，它会构建一个仅包含你提供的那个项的序列。

<code language="clj">
user=> (cons 1 nil)
(1)
</code>

接下来是另一个很常见的Lisp惯用法，使用`cons`或者`conj`来递归地构建一个list。下面的这个函数展示了使用从1到用户输入的参数之间的所有整数来递归构造的一个序列：

<code language="clj">
(defn make-int-seq `[max]`

     (loop `[acc nil n max]`

          (if (zero? n)
          acc
          (recur (cons n acc) (dec n)))))
</code>

在每次迭代中，这个函数将n（初始为最大值）用`cons`函数添加到一个累加器（accumulator）序列（初始化为nil）中，然后递归，将新的累加器和新的被减一（decremented）的n传入。当n累减直0之后，函数将这个累加器序列返回，这时它已经包含了所有1到最大值。

<code language="clj">
user=> (make-int-seq 5)
(1 2 3 4 5)
</code>

=延迟加载的序列=

延迟加载（laziness，等同于惰性），Clojure中序列另一个极为重要的方面，是以first/rest结构为基础的。延迟加载为操作那些数据量太大以至于无法一次加载到系统内存的数据提供了一种概念上十分简单，同时也相当搞笑的方式。这些数据可以具有无穷的长度，却依旧可以被任意标准序列函数高效地使用。延迟加载的序列作为一种高阶抽象，它是开发者能够专注于那些正在进行的计算，而不是去管理加载和创造数据的繁琐细节。

延迟加载这种概念是根据这样一个观察和研究得到的：逻辑上讲，一个序列的`rest`部分实际上并不是必须存在的，只要可以在需要的时候创建就行了。延迟加载序列的`rest`部分可以被实现为返回一个序列的函数，而不是包含一个实际的明确的一系列值。从使用这个序列的函数来看，这并没有什么差别；当他们调用`rest`函数的时候，他们得到了一个序列。不同仅仅在于如果是一个一般的序列，它会返回一个已经存在与内存中的数据结构。在延迟加载序列中，调用`rest`实际上计算并初始化了一个新的序列，这个序列使用刚刚计算出来的值作为它的`first`，使用一系列有关如何生成更多的值的指令（一系列代码）作为它的`rest`。

考虑到效率问题，一旦延迟加载的序列被实现（realize），得到的值将被作为正常的非延迟加载的序列缓存下来——之后对这个序列的访问将会以正常的方式访问，而不是被延迟地产生。这样保证了延迟加载所需的计算只会被运行一次：在延迟加载的时候使用大量的，沉重繁复的的计算将不会导致任何的性能问题，因为这种机制保证了它们只会运行一次。只要有代码在使用这些缓存的值，它们就会一直存在。当没有任何引用存在的时，这些缓存的值会像其他所有对象一样被作为垃圾回收。

==一个延迟加载的例子==

想要看看延迟加载序列如何工作，可以想想`map`函数。`map`函数是Clojure中一个极为重要的序列操作工具。它需要一个序列和一个函数作为输入参数，它将这个函数应用到所提供序列中每一项，根据返回值得到一个新的序列。举个例子，如果你将序列`'(1 2 3 4 5 6 7)`和一个将参数平方的函数，`(fn [x] (*x x))`传入`map`，它的返回值则为`(1 4 9 16 25 36 49)`。这就是将所有原序列中的项平方之后得到的结果。

<code language="clj">
user => (map
                (fn [x] (* x x))
                       '(1 2 3 4 5 6 7))
(1 4 9 16 25 36 49)
</code>
