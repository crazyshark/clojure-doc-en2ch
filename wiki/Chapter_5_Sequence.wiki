#Start at Fri 14, Oct 2011
<wiki:toc max_depth="3" />

=什么是序列？=

在Clojure中，任何逻辑是可看做数据项集合(collection of items)的数据结构都可以使用序列这样一种统一的方式来读取，写入和修改。在非常基础的层次上，序列被整合进了Clojure，同时也是目前为止最为方便和符合规范的处理集合的方式。他们的角色等同于列表(lists)在其他Lisp方言中的角色。但是，序列不仅仅是一个操作集合的API(a collection API)，他们通常还作为框架(framework)以方便Clojure程序中流程和逻辑的构件，同时，简单易用的设计也使他们作为递归和高阶函数相关应用的基础。

从根本上来说，序列是一中抽象，将对所有集合的一些通用行为泛化喂一些通用的编程接口，然后将其通过一个由_序列函数_(_sequence functions_)组成的库(library)暴露出来以方便使用。基于对链接表(linked lists)的一些经典的操作，例如“`first`”和“`rest`”，(或者“`car`”和“`cdr`”，对那些有lisp北京的人来说)的观察，我们设计出了序列，而且可以说序列在任何数据类型上都能工作的同样好。举个例子，`first`函数返回一个序列的第一个项(item)。无论这个序列实际上是一个列表，向量，集合(set)，或者甚至是一个键值对(map)，都没有任何区别。

<code language="clj">
user=> (def mylist '(1 2 3))
user=> (first mylist)
1

 user=> (def myvec [1 2 3])
user=> (first myvec)
1

 user=> (def myset #{1 2 3})
user=> (first myset)
1

 user=> (def mymap {:a 1 :b 2 :c 3})
user=> (first mymap)
[:a 1}
</code>

相似的，`rest`函数对于任何序列返回剔除了第一个项的一个新的序列：

<code language="clj">
user=> (def mylist '(1 2 3))
user=> (rest mylist)
(2 3)
</code>

序列函数是非常有用的。举个例子，只需要`first`和`rest`(还需要另一个函数，`empty?`，如果一个序列为空则放回true)就能实现一个Lisp中极为常见的惯用语：递归遍历一个列表的函数。但是，因为你使用的是序列，除了列表，你可以遍历任何数据集合。

<code language="clj">
(defn printall [s]
    (if (not (empty? s))
        (do
            (println (str "Item: " (first s)))
            (recur (rest s)))))
</code>