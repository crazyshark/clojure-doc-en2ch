==章九 多路方法和层次结构==

===没有类的运行时多态===
<p>
以传统的对类和方法的观点来看，Clojure不是一门面向对象的语言，虽然它构建在Java面向对象的基础设施之上。<br/>
大多数主流的，像Java和C++这样的面向对象语言，用类定义树形的类型层次结构，并提供这些类型所包含的方法的实现。<br/>
Clojure分离了类型层次结构和方法实现，极大地简化了多重继承带来的问题。另外，它允许你在同一个类型上建立多重的，独立的层级结构。这使得定义更贴近现实世界的IS-A关系模型成为可能 。
</p>

===多路方法===
<p>
Clojure 多路方法为运行时多态的分发提供了支持。它允许你给一个方法定义提供多个实现。在运行时，哪个实现被执行取决于方法被赋予的参数。<br/>
很多面向对象语言的方法分发，是单变量的、基于类型的，哪个方法被执行，完全由第一个参数所属的类型或类来决定。方法在第一个参数上被调用。Java和C++都把第一个参数放到方法名前面来明确它的重要意义。<br/>
Clojure 多路方法更为灵活。它支持多重分派，任何变量都能把实现挂到同一个方法上。同样地，分发将基于变量的任何特征，而不单单是类型。<br/>
多路方法使用关键字***defmulti***创建，使用***defmethod***实现。
<code>
(defmulti name dispatch-fn)
(defmethod multifn dispatch-value `[args...`] & body)
</code>
</p>

====多重分派====

====默认分派值====


===层次结构===

====查询层次结构====


===Multimethods的层次结构===

====Java的层次结构====

====更多的层次结构查询====

====解决冲突====

====类型标记====


===用户定义的层次结构===


===总结===
<p>
多路方法非常灵活，但是灵活性是有代价的：不是很高效。考虑一下每次我们调用多路方法时候会发生什么：为了能找到正确的方法，它不得不去调用一个分发函数，查找哈希表里的分发值，然后最少做一次***isa?***对比。像Hotspot这样的小型编译器再优化的烂点儿，oh, my God<br/>

</p>