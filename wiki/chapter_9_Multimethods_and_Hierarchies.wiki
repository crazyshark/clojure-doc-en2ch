==章九 多路方法和层次结构==

===没有类的运行时多态===
<p>
以传统的对类和方法的观点来看，Clojure不是一门面向对象的语言，虽然它构建在Java面向对象的基础设施之上。<br/>
大多数主流的，像Java和C++这样的面向对象语言，用类定义树形的类型层次结构，并提供这些类型所包含的方法的实现。<br/>
Clojure分离了类型层次结构和方法实现，极大地简化了多重继承带来的问题。另外，它允许你在同一个类型上建立多重的，独立的层级结构。这使得定义更贴近现实世界的IS-A关系模型成为可能 。
</p>

===多路方法===
<p>
Clojure 多路方法为运行时多态的分发提供了支持。它允许你给一个方法定义提供多个实现。在运行时，哪个实现被执行取决于方法被赋予的参数。<br/>
很多面向对象语言的方法分发，是单变量的、基于类型的，哪个方法被执行，完全由第一个参数所属的类型或类来决定。方法在第一个参数上被调用。Java和C++都把第一个参数放到方法名前面来明确它的重要意义。<br/>
Clojure 多路方法更为灵活。它支持多重分派，任何变量都能把实现挂到同一个方法上。同样地，分发将基于变量的任何特征，而不单单是类型。<br/>
多路方法使用关键字***defmulti***创建，使用***defmethod***实现。
<code>
(defmulti name dispatch-fn)
(defmethod multifn dispatch-value `[args...`] & body)
</code>

多路方法的调用和普通方法是一样的。当你调用它的时候，分发函数被赋予和多路方法相同的参数立即被调用。分发函数返回的值叫做分发值。然后Clojure搜索分发值对应的方法（由defmethod定义）。<br/>
假设你在写一个幻想类角色扮演游戏，里面有不同种类的生物：人类、精灵、兽人、等等。每个生物用一个map描述，如下：
<code>
(def a {:name "Arthur", :species ::human, :strength 8})
(def b {:name "Balfor", :species ::elf, :strength 7})
(def c {:name "Calis", :species ::elf, :strength 5})
(def d {:name "Drung", :species ::orc, :strength 6})
</code>

将名称空间限定的关键字用于物种（::human代替:human），这个后面详述起重要性。（第七章有关于限定关键字的解释）<br/>
现在你可以定义一个区分不同物种生物的多路方法。例如，你能够给每个物种不同的移动方式。
<code>
(defmulti move :species)

 (defmethod move ::elf `[creature`]
    (str (:name creature) " runs swiftly."))

 (defmethod move ::human `[creature`]
    (str (:name creature) " walks steadily."))

 (defmethod move ::orc `[creature`]
    (str (:name creature) " stomps heavily."))
</code>

当你调用***move***的时候，适当的方法会被调用。
<code>
user=> (move a)
"Arthur walks steadily."
user=> (move b)
"Balfor runs swiftly."
user=> (move c)
"Calis runs swiftly."
</code>

发生了什么？当你调用（move a），首先Clojure为定义于关键字:species上的move多路方法调用分发方法。那个关键字，会被用于从map中找到一个对应值。所以（move a）调用（:space a），返回::human。然后Clojure会为move找到一个分发值为::human的方法，调用它。<br/>
相同的行为可以被有条件地实现。多路方法的优点是你能在任何时候添加新方法。当你增加一个新物种生物的时候，你可以简单的定义另一个move方法，而不用修改以后的代码。<br/>
分发方法可不是只能使用简单的关键字；任何函数都是可以的。例如，你能让分发方法按照力量对生物分类。
<code>
(defmulti attack (fn `[creature`]
                    (if (> (:strength creature) 5)
                        :strong
                        :weak)))

 (defmethod attack :strong `[creature`]
    (str (:name creature) " attacks mightily."))

 (defmethod attack :weak `[creature`]
    (str (:name creature) " attacks feebly."))
</code>

当你调用***attack***多路方法的时候，会先调用匿名方法fn，它返回***:strong***或者***:weak***。这个关键词（分发值）决定了哪个attack方法被掉用。
<code>
user=> (attack c)
"Calis attacks feebly."
user=> (attack d)
"Drung attacks mightily."
</code>
</p>

====多重分发====
<p>
就像我在这章最开始时候说的那样，多路方法提供了对多参数的分发的支持。为了做到这点，分发方法返回一个vecter。例如，在游戏中，定义一个多路方法描述两个不同物种碰面时候会发生什么。比方说精灵，它们和兽人敌对，和其他种族友好：
<code>
(defmulti encounter (fn `[x y`]
                        `[(:species x) (:species y)`]))
(defmethod encounter `[::elf ::orc`] `[elf orc`]
    (str "Brave elf " (:name elf)
        " attacks evil orc " (:name orc)))
(defmethod encounter `[::orc ::elf`] `[orc elf`]
    (str "Evil orc " (:name orc)
        " attacks innocent elf " (:name elf)))
(defmethod encounter `[::elf ::elf`] `[orc1 orc2`]
    (str "Two elves, " (:name orc1)
        " and " (:name orc2)
        ", greet each other."))
</code>

注意方法参数不必跟多路方法相同，但是分发方法和方法的参数数量必须相同。<br/>
现在以两个生物为参数调用encounter多路放下，看会发生什么：
<code>
user=> (encounter b c)
"Two elves, Balfor and Calis, greet each other."
user=> (encounter d b)
"Evil orc Drung attacks innocent elf Balfor"
</code>
</p>

====默认分派值====
<p>

<code>
user=> (encounter a c)
java.lang.IllegalArgumentException:
No method in multimethod 'encounter'
for dispatch value: `[:user/human :user/elf`]
</code>


<code>
(defmethod encounter :default `[x y`]
    (str (:name x) " and " (:name y)
        " ignore each other."))
</code>


<code>
user=> (encounter a c)
"Arthur and Calis ignore each other."
</code>


<code>
(defmulti talk :species :default "other")
(defmethod talk ::orc `[creature`]
    (str (:name creature) " grunts."))
(defmethod talk "other" `[creature`]
    (str (:name creature) " speaks."))
</code>
</p>

===层次结构===
<p>

<code>
(derive child parent)
</code>


<code>
user=> (derive ::human ::good)
user=> (derive ::elf ::good)
user=> (derive ::orc ::evil)
</code>


<code>
user=> (derive ::elf ::magical)
user=> (derive ::orc ::magical)
</code>


<code>
user=> (derive ::hero ::human)
</code>

***img here***
</p>

====查询层次结构====
<p>

<code>
(isa? child parent)
</code>


<code>
user=> (isa? ::orc ::good)
false
user=> (isa? ::hero ::good)
true
user=> (isa? ::hero ::magical)
false
</code>


<code>
user=> (isa? ::human ::human)
true
</code>
</p>

===多路方法的层次结构===
<p>

<code>
(defmulti cast-spell :species)

 (defmethod cast-spell ::magical `[creature`]
    (str (:name creature) " casts a spell."))

 (defmethod cast-spell :default `[creature`]
    (str "No, " (:name creature) " is not magical!"))

 user=> (cast-spell c)
"Calis casts a spell."
user=> (cast-spell a)
"No, Arthur is not magical!"
</code>


<code>
(defmulti encounter (fn `[x y`]
                        `[(:species x) (:species y)`]))

 (defmethod encounter `[::good ::good`] `[x y`]
    (str (:name x) " and " (:name y) " say hello."))

 (defmethod encounter `[::good ::evil`] `[x y`]
    (str (:name x) " is attacked by " (:name y)))

 (defmethod encounter `[::evil ::good`] `[x y`]
    (str (:name x) " attacks " (:name y)))

 (defmethod encounter :default `[x y`]
    (str (:name x) " and " (:name y)
        " ignore one another."))

 user=> (encounter c a)
"Calis and Arthur say hello."
user=> (encounter a d)
"Arthur is attacked by Drung"
</code>
</p>

====Java的层次结构====
<p>

<code>
user=> (derive java.util.Date ::evil)
</code>


<code>
user=> (isa? java.util.Date ::evil)
true
user=> (isa? Float Number)
true
</code>


<code>
(defmulti invert class)
(defmethod invert Number `[x`]
    (- x))
(defmethod invert String `[x`]
    (apply str (reverse x)))
user=> (invert 3.14)
-3.14
user=> (invert
</code>
</p>

====更多的层次结构查询====
<p>

<code>
(parents tag)
(ancestors tag)
(descendants tag)
</code>


<code>
user=> (parents ::orc)
#{:user/magical :user/evil}
user=> (descendants ::good)
#{:user/elf :user/hero :user/human}
user=> (parents ::hero)
#{:user/human}
user=> (ancestors ::hero)
#{:user/good :user/human}
user=> (parents java.util.Date)
#{java.lang.Object java.lang.Cloneable
    java.io.Serializable java.lang.Comparable
    :user/evil}
</code>
</p>

====解决冲突====
<p>

<code>
(defmulti slay :species)

 (defmethod slay ::good `[creature`]
    (str "Oh no! A good creature was slain!"))

 (defmethod slay ::magical `[creature`]
    (str "A magical creature was slain!"))
</code>


<code>
user=> (slay a) ;; human
"Oh no! A good creature was slain!"
user=> (slay d) ;; orc
"A magical creature was slain!"
</code>


<code>
user=> (slay b)
java.lang.IllegalArgumentException:
Multiple methods in multimethod 'slay' match
dispatch value: :user/elf -> :user/magical
and :user/good, and neither is preferred
</code>


<code>
(prefer-method multimethod preferred-value other-value)
</code>


<code>
user=> (prefer-method slay ::good ::magical)
user=> (slay b)
"Oh no! A good creature was slain!"
</code>


<code>
(remove-method multimethod dispatch-value)
</code>


<code>
user=> (remove-method slay ::magical)
user=> (slay b)
"Oh no! A good creature was slain!"
</code>
</p>

====类型标记====
<p>

<code>
user=> (type (with-meta {:name "Bob"} {:type ::person}))
:user/person
user=> (type 42)
java.lang.Integer
user=> (type {:name "Alice"})
clojure.lang.PersistentArrayMap
</code>


<code>
(def a (with-meta {:name "Arthur", :strength 8}
        {:type ::human}))
(def b (with-meta {:name "Balfor", :strength 7}
        {:type ::elf}))
</code>


<code>
(defmulti move type)

 (defmethod move ::elf `[creature`]
    (str (:name creature) " runs swiftly."))

 (defmethod move ::human `[creature`]
    (str (:name creature) " walks steadily."))
</code>


<code>
(defmethod move Number `[n`]
    (str "What?! Numbers don't move!"))

 user=> (move a)
"Arthur walks steadily."
user=> (move b)
"Balfor runs swiftly."
user=> (move 6.022)
"What?! Numbers don't move!"
</code>
</p>

===用户定义的层次结构===
<p>

<code>
user=> (def h (make-hierarchy))
user=> (derive h :child :parent)
user=> (isa? h :child :parent)
false
</code>


<code>
user=> (def h (-> (make-hierarchy)
                (derive :one :base)
                (derive :two :base)
                (derive :three :two)))
user=> (isa? h :three :base)
true
</code>


<code>
user=> (def h (make-hierarchy))
user=> (isa? h :child :parent)
false
user=> (alter-var-root (var h) derive :child :parent)
user=> (isa? h :child :parent)
true
</code>
</p>

===总结===
<p>
多路方法非常灵活，但是灵活性是有代价的：不是很高效。考虑一下每次我们调用多路方法时候会发生什么：为了能找到正确的方法，它不得不去调用一个分发函数，查找哈希表里的分发值，然后最少做一次***isa?***对比。像Hotspot这样的小型编译器再优化的烂点儿，oh, my God<br/>
结果就是，多路方法对于频繁调用的低级别函数不适合。这就是Clojure的内置函数都不用多路方法实现的原因。尽管如此，它用来创建可扩展的高级别API是非常棒的。分别在1.2节和13章介绍和详细描述的协议，提供了一个严格的方法分发的形式，并有着不错的性能。
</p>