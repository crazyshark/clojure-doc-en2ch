==章九 多路方法和层次结构==

===没有类的运行时多态===
<p>
以传统的对类和方法的观点来看，Clojure不是一门面向对象的语言，虽然它构建在Java面向对象的基础设施之上。<br/>
大多数主流的，像Java和C++这样的面向对象语言，用类定义树形的类型层次结构，并提供这些类型所包含的方法的实现。<br/>
Clojure分离了类型层次结构和方法实现，极大地简化了多重继承带来的问题。另外，它允许你在同一个类型上建立多重的，独立的层级结构。这使得定义更贴近现实世界的IS-A关系模型成为可能 。
</p>

===多路方法===
<p>
Clojure 多路方法为运行时多态的分发提供了支持。它允许你给一个方法定义提供多个实现。在运行时，哪个实现被执行取决于方法被赋予的参数。<br/>
很多面向对象语言的方法分发，是单变量的、基于类型的，哪个方法被执行，完全由第一个参数所属的类型或类来决定。方法在第一个参数上被调用。Java和C++都把第一个参数放到方法名前面来明确它的重要意义。<br/>
Clojure 多路方法更为灵活。它支持多重分派，任何变量都能把实现挂到同一个方法上。同样地，分发将基于变量的任何特征，而不单单是类型。<br/>
多路方法使用关键字***defmulti***创建，使用***defmethod***实现。
<code>
(defmulti name dispatch-fn)
(defmethod multifn dispatch-value `[args...`] & body)
</code>
</p>


<code>
(def a {:name "Arthur", :species ::human, :strength 8})
(def b {:name "Balfor", :species ::elf, :strength 7})
(def c {:name "Calis", :species ::elf, :strength 5})
(def d {:name "Drung", :species ::orc, :strength 6})
</code>


<code>
(defmulti move :species)
(defmethod move ::elf `[creature`]
    (str (:name creature) " runs swiftly."))
(defmethod move ::human `[creature`]
    (str (:name creature) " walks steadily."))
(defmethod move ::orc `[creature`]
    (str (:name creature) " stomps heavily."))
</code>


<code>
user=> (move a)
"Arthur walks steadily."
user=> (move b)
"Balfor runs swiftly."
user=> (move c)
"Calis runs swiftly."
</code>


<code>
(defmulti attack (fn `[creature`]
                    (if (> (:strength creature) 5)
                        :strong
                        :weak)))
(defmethod attack :strong `[creature`]
    (str (:name creature) " attacks mightily."))
(defmethod attack :weak `[creature`]
    (str (:name creature) " attacks feebly."))
</code>


<code>
user=> (attack c)
"Calis attacks feebly."
user=> (attack d)
"Drung attacks mightily."
</code>


====多重分派====

====默认分派值====


===层次结构===

====查询层次结构====


===Multimethods的层次结构===

====Java的层次结构====

====更多的层次结构查询====

====解决冲突====

====类型标记====


===用户定义的层次结构===


===总结===
<p>
多路方法非常灵活，但是灵活性是有代价的：不是很高效。考虑一下每次我们调用多路方法时候会发生什么：为了能找到正确的方法，它不得不去调用一个分发函数，查找哈希表里的分发值，然后最少做一次***isa?***对比。像Hotspot这样的小型编译器再优化的烂点儿，oh, my God<br/>
结果就是，多路方法对于频繁调用的低级别函数不适合。这就是Clojure的内置函数都不用多路方法实现的原因。尽管如此，它用来创建可扩展的高级别API是非常棒的。分别在1.2节和13章介绍和详细描述的协议，提供了一个严格的方法分发的形式，并有着不错的性能。
</p>