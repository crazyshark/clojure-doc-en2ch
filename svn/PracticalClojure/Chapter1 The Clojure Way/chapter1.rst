===========================通往Clojure之路===========================-----------------------Clojure 的理念和特性-----------------------什么是Clojure,为什么有人要学这门语言? 总的来说,那些认为 Clojure会在现有的大多数编程语言中取得成功的人至少基于这样一个理由:  **它是一门新的,支持并发的语言** .而那些对lisp语言缺乏了解的人却往往会认为:这是一门相当奇怪的,充斥着令人困惑的 圆括号 和 方括号 的语言.但是,不争的事实是,Clojure 在市场上赢得比其他新诞生的编程语言更多的追捧和表现了更强的发展势头. 它第一个对外的发行版是在 2007年秋季的时候发布的,在2009年5月发行了第一个稳定版,到这个时候,它已经培育了一个活跃的,充满热情的社区,一个欣欣向荣的开发工具和类库的生态系统,它们被用在迅速增长的一系列专业的应用程序中.下一代的语言==================每一年,在世界范围内的众多机构中的都有很多有才华的计算机科学家通过发表成千上万的论文来阐发它们新的和有趣的想法. 这些新的概念在经受了自然选择和沉淀后,其中那些优秀和有用的部分会被准许进入实际的应用环境中.Clojure 包括了众多 尚未在其他(任何)编程语言的实现中出现的 最新的想法和伟大的理念.这其中最引人注目的就是涉及 并发程序 的部分:  软件内存交互和基于代理的进程调度(Software Transactional Memory and agent-based processing ) 被 "烧录进" (嵌入)到Clojure编程语言的底层. 除此之外(例如 持续不可更改 persistent immutability) 还拥有很多精妙的设计理念,这些设计理念是现代学术研究的成果,也是数十载实践的经验.抛开Clojure的学术背景,Clojure 是主要设计原则是坚持: 有用性(useful 有益处的) 高于可用性.  它的高级属性是被精心选择的,目的是向程序员提供 健壮的、干净的代码，以便程序员容易理解和高效编程. Clojure虽然有很强的学术背景支持,但是绝不是一门只在象牙塔中的语言,每天都有众多开发者在各自的开发领域内使用它.动态而强有力 (没错,它是lisp!)==================================对下面语句的意思的理解会因为读者编程经验的不同而有很大差异,它可能会让你非常兴奋,页可能让你产生一些轻微的不适. **Clojure 是完全的,真正意义上的神圣的lisp语言的一个方言**lisp语言因为其无以伦比强大能力和几乎无穷的表达力而获得了盛誉,Clojure自然也不例外.它的功能和元编程的能力是建立在这样的基础之上的:异常驯服的C语言的"石头" 或 具有延展性的java语言的"木头" . 你可以用几百行甚至几十行Clojure代码取替代几千行静态语言的代码,伴随着这而来的是bug数量的减少和开发时间的缩短.样板代码(Boilerplate code )被完全删去. 域指定语言(Domain Specific Languages ) 不仅简单,而且更一般化--lisp程序往往是按照 "自下而上" 的开发方式写成的. 展开式(演进式)的结构和语法更适合特定的问题领域. 你在程序运行的时候取修改程序,而不需要重新编译或重启程序.但是,历史上也有对lisp进行诋毁的人,或许称为抱怨更为合适. lisp发展过程中,没有完整的规范,各种不兼容的实现,陈旧落伍的限制.cruft accumulate 在其存在的四五十年里一直存在. 对于大多数人来说,它的语法过于诡异了.Clojure 修正上面的大多数这些问题. 它保留了 lisp 的思想和哲学,并同时清除了过去的很多限制.Clojure 高速、干净、具有优先能力和优雅的特征. 但是没有改变lisp中 "代码也是数据" 的哲学.Clojure 语言在直觉和观感上比历史上的lisp更易于阅读. 在后面开始学习的初级阶段,你就发现虽然仍有各种括号,但是代码是难以置信的容易读和写.对于那些熟悉lisp语言的人来说,他们很快就会发现他们非常适应Clojure. 对于那些原先没有接触过lisp的人来说,也没有必要担心. Clojure是简洁和无痛学习lisp语言的方法,它更容易让人们对lisp燃起热情,而不需要经受上面提到的那些不好的东西.如果你坚持来下,那么在你玩了几周的代码之后,你很可能会喜欢喜欢上它,甚至是它的括号.Java平台======================无论你是否喜欢Java语言, Java虚拟机都是非常好的值得尊敬的软件.它是成熟、稳定和迅速的。作为一个工业标准,它有成千上万的经过良好测试的应用于各个方面类库.很多公司都在Java平台上进行了巨大投资.因为运行在Java虚拟机上,Clojure是可以很容易获取和使用的.它不仅仅是移植到Java虚拟机上的一门语言:Clojure是重新设计,运行在Java环境下,能与Java进行容易整合的语言.对于程序开发,它同样是非常出色的,不管是作为一个完整的,独立的语言,还是作为在Java程序中内嵌的脚本工具使用.它可以在任何Java能够运行的环境下使用,而且在更多情况下更容易编写.-------------------函数式编程-------------------clojure的一个关键特性是它是一门函数式语言,这意味着函数是作为程序的基础构建块而不是作为命令(指令)存在的,不像其他编程语言一样(例如命令式的语言).函数式编程提供了一些比命令式语言更重要的益处.这些会在本部分被讨论. 函数式的风格是Clojure与生俱来的,并且是它的理念的核心... note::   几乎所有的编程语言都提供了一个被称为函数的构造形式.在大多数编程语言中,最好把函数   理解为子程序,是为了方便使用,而将一组相关的代码进行汇集起来供使用.   在Clojure和其他函数式语言中,其中关于函数的概念更像是数学中的概念--一个函数是一个   简单的操作,获取一定数量的参数(又称自变量) 然后返回一个值.命令式语言通过执行大量的指令来执行一个复杂的任务,这些指令按照顺序修改程序状态,知道达到期望的结果.而函数式语言完成同样的目标,是通过对不同函数的嵌套组合--将一个函数的结果作为参数传递给下一个函数,直至达到最后的目标.通过编写和串接函数,还有函数的迭代,一个函数式程序可以表达出任何计算机能够完成的任务. 一个完整的程序式程序可以被看做是一个单一的函数,是一个由众多子函数组合在一起而定义的函数.嵌套结构决定了程序的执行顺序,而所有的数据则是通过函数的参数和返回值来进行处理的... image:: figure1.1.png   :width: 70%.. image:: figure1.2.png   :width: 70%事实上,这正式那些不熟悉函数式编程的人认为Clojure代码看起来非常奇怪的原因.Clojure是被优化用来更方便地表达函数组合,而不是用来表达指令块地. 随着你对函数式语言经验和理解地增长,你会觉得Clojure地语法越来越自然.***********************************函数式和指令式地等价在计算机科学上的一个重要的事实是,函数式计算模型和指令式计算模型是正式等价的,所以它们都拥有表达任何可能的计算任务的能力.这一概念要追溯到计算机科学的早期. 阿兰.图灵 的开创性的论文,在 *Computable Numbers(1936*描述了指令计算机的抽象模型,后来被称为 **图灵机** . 现代计算机就是基于这个概念模型的. 早些时候,Alonzo Church 独立完成了另一篇论文,叫做 << An Unsolvable Problem of Elementary Number Theory >> .在这篇论文中,他创造了一个被称为 λ演算的系统--函数式语言就是建立在这个基础之上的.这两种不同的计算表达方式很快就被发现在数学上具有等价性,然后它们被合称为Church-Turing理论.这一理论不仅是几个数学领域内非常重要的结论,也成为方兴未艾的计算机科学的起点.***********************************纯粹的函数式编程=========================**纯函数** 是函数式编程中的一个重要概念,就像figure1-3显示的.简单的来说,一个纯函数是指一个只接受参数,然后返回值的函数. 如果一个函数除了调用时候的参数还读取了其他内容,那么它就不是纯函数. 如果这个函数在调用过程中改变了程序中的任何状态(被称为副作用),它就不是一个纯函数.函数式编程将很大的注意放在对程序中状态和副作用的精心管理(或者说是尽量避免).虽然这两者(两者:对程序中状态的改变和副作用)对程序完成可能的任何任务来说是不可避免的,是必要之恶,但是函数式编程的程序员仍然尽量避免使用它们.状态 是指程序中储存的可能被一段或者多段代码所改变的数据. 这是非常危险的,因为代码的行为往往取决于这些状态,但是我们很难跟踪和分析这些代码有没有做了不应该做的事情,例如程序中的任何一段代码都可能修改了状态值. 这一问题在并发程序中会呈集合增长,它很难分辨,甚至是代码运行的顺序都是无法识别的,那么预测一个给定的状态值更是不可能的.副作用 是指函数在执行过程中除了返回值以外做的其他事情. 如果改变了程序状态,并写入了磁盘或者执行了任何形式的IO操作,它都是执行了(产生了)副作用. 当然,副作用对于程序和其他包括用户在内的交互是必要的.但是它们会让函数变得难以理解,并且难以在其他地方重用... image:: figure1.3.png   :width: 70%纯函数编程拥有的几个优势:   * 更容易进行并发编程(平行计算) .因为每一个函数都是不同的,独立的单元,不管函数在同一个     进程中运行或者在同一个机器上运行都是一样的.   * 纯函数 可以实现更好的封装性和重用性. 每一个函数实际上都是一个黑箱. 所以,理解了输入     和输出,你就理解了一个函数. 不需要知道这个函数是如何实现的. 面向对象开发企图实现这个     目标,但实际上它是无法保证做到这一点的,因为对象拥有自己的状态. 一个对象类型和方法显然     不能告诉你整个内容(故事);程序员仍然需要知道如何管理对象的状态,以及对象的方法会那些     状态产生什么影响. 在一个复杂的系统中,快速增长的复杂性经常抵消了类封装带来的好处.     但是,纯函数编程中,一个纯函数完全可以通过对它的接口(输入的参数,返回的值)的描述来完整     描述它的功能,而不需要依赖其他附加的信息.   * 它们更容易保持理性. 在一个纯函数式程序中,执行树式非常简单的.通过跟踪函数的调用结构     ,你就可以准确说明整个程序所做的事情. 为了理解一个指令,具有状态的程序中,你不仅需要了解     代码,还要了解状态在各种可能的情况的存在值. 纯函数编程显得更加直观透明.在某些情况下,     它甚至可以自动分析和转换一些源代码,而这些行为是不太可能出现在指令式的语言中的.      * 纯函数可以很容易编写单元测试代码. 单元测试最难的地方就是预测和存取所有可能的组合状态     和执行路径. 纯函数具有的良好的定义,无状态行为,让这一切都变得非常简单.clojure的折中=========================当然,大多数程序无法完全使用纯函数编程. 副作用式不可避免的.在屏幕上显示内容,从硬盘上读取文件,或者通过网络发送消息,这些副作用都是不可避免的.同样,整个程序很难做到完全无状态. 真实的世界中是有状态的,真实环境下的程序也是需要存储和处理数据的,而且可以随着时间改变而变化.实际上,Clojure并不强制必须使用纯函数的编程方式.但是少数语言会强制要求必须使用纯函数式的编程方式,例如Haskell就是这样做的,它们被认为式更加偏向学术化,难以学习,更难以应用于现实中发生的问题的解决上. Clojure并不组织程序员使用状态或者副作用,只是让这一切更加安全和简单.Clojure采用了两种方式,既保持尽可能的函数式开发,同时还允许开发人员轻松的做他们需要做的一切.   * 副作用被明示的,而不是被作为规则的例外. 在需要它们的时候,他们被添加,它们被从程序流     中突出出来.这可以保证程序员可以知道副作用在什么时候发生,为什么发生以及发生后的影响.      * 所有的程序状态都是被包含在线程安全的结构中的,Clojure精心设计了并发管理功能.这确保     这确保了最低限度的影,程序状态总是安全和一致的.更新状态是显式的、原子性（独立）和     可以清晰辨别的。Clojure 的很多独特的风格都是源于上面这两个特点。自然的，Clojure有意将代表分为两个部分，一个是纯函数式的（没有副作用和状态改变的情况），另一个是产生影响的部分（effect－producing），单独的函数来包含产生副作用的部分和改变状态的部分，而纯函数部分则用来处理程序的逻辑的部分。这种做法保留了Clojure程序中的纯函数式设计的诸多优点，同样也是值得被鼓励的编程风格。当然就像其他语言一样，你也可以用Clojure写出杂乱、混淆不清的代码。但是Clojure语言本身的设计鼓励你编写容易阅读和调试的代码。显式的状态和副作用意味着更容易阅读一个程序，了解它在作什么，而甚至不需要知道它是如何这样做的。.. warning::   Java 对象：这是Clojure 关于状态管理和副作用规则的一个例外。Clojure允许你在编写程序的   时候将Java对象和Clojure的结构配合使用，但是Java对象仍然是Java对象，保留了完整的不被   clojure管理的状态。 它实际上没有什么太大的作用。一个良好的Clojure程序只会在和Java库的   接口部分才会用到Java对象，所以应该限制使用可变状态（指不被Clojure管理的）。永久不可变性=====================Clojure鼓励采用函数式的编程风格,因此在必须采用某种方式提供一种功能强大的、高校的 不可变的数据结构。不可变数据结构（Immutable data structures）正如其名字所表述的意思，这种数据结构具有不可改变性。他们用制定的值或内容创建，然后在这个对象存在的周期里面一直保持不变。 这确保了这个对象可以自由的被使用在不同的地方，在多线程的地方，不用担心条件和其他冲突的发生。如果一个对象是只读的，那么它总是可以被安全地使用在程序中的各个地方。这便引出一个问题，那就是如果程序逻辑需要，数据结构能够改变么？ 这个问题上的回答非常简单，不是去修改现有的数据结构（可能导致使用这个数据结构的代码部分发生各种不良影响），而是创建新的数据结构，用原有数据结构中的内容和对他的改变的结果来初始化这个新的数据结构。（参考figures 1.4 和figures1.5 注：此部分直译很难表达准确意义，采用意译。附原文)。那个原来的数据结构对象仍然维持原样，可以被其他线程和其他部分的代码所使用，而不会带来任何问题，这些代码不会知道有一个被改变的数据结构的新版本存在。 同时，“改变”了对象的代码继续使用新的对象，除了对旧对象的修改。这听起来也许是很低效的，但是实际上并不是这样的。因为base object 是不改变的，所以“被修改”的对象可以共享其除了实际修改处以外的结构。 系统只需要储存那些不同的地方，而不需要保持一个完整的对象拷贝。这种属性被称为 persistence(持续性) -- 一个数据结构结构和其自身的前一个版本（即“修改"前）共享内存。这种机制下，一个改变会占用一段小的计算开销，但是内存的使用率却可以保持在较低的水平。在大多数情况下，对象（相同对象的不同版本）可以共享数据结构的大部分，以提高效率。 当对象的旧版本仍然被对象的新版本部分使用（共享一部分数据结构）时，它对继续存在。当他们不在被使用时(既无直接使用，也无间接使用),他们就会被垃圾收集所释放。.. image:: figure1.4.png   :width: 70%.. image:: figure1.5.png   :width: 70%不可改变性的另一个有趣的影响是，持久的数据结构(persisten data objects )可以很容易保持前一个版本，如果必要的话，可以回滚到原来的版本。 这一特性让它可以非常容易和有效的实现撤销历史和回溯算法等类似的东西。   Clojure提供了下面这些普通的永久不可变数据结构：   * Linked lists: 简单的，单链的列表，可以支持快速的便利和插入操作。   * Vectors: 和数组类似，vectors 采用整数值来索引值，它支持通过整数索引来快速查找对应     的值。   * Hash maps: 哈希映射 使用哈希Trie树的数据结构构建 键/值对 的无序存储,并支持快速的     查找。   * Sorted maps: 通过在底层使用平衡二叉树(balanced binary tree)，实现有序的 键/值对查询     它们也毫无疑问的提供了排序和其他哈希映射所拥有的操作，只不过这些操作要比哈希映射慢。   * Hash and sorted sets: 集合是一组互不相同的元素所组成的整体，类似于数学中的 **集合**     概念。它们支持集合的 并 交 补 等操作。 它们可以被实现用来充当哈希树 或者被用来实现     类似一个性能有所折中的映射实现。这些对象不仅具有不可改变性，还拥有下面这些有趣的属性：   * 它们支持基于值为基础的是否相等的快速比较--两个数据结构是否相等，当且仅当它们所包含     的元素完全相同。   * 它们在java.util.*collection interfaces(也就是集合，列表和映射) 和java.lang.Iterable      的API处被不可选择的和只读的实现。这意味着它们可以被用来当作很多Java集合对象的简单     替代，使得更容易与Java库衔接。   * 它们完全实现了序列的抽象。这部分将会在第五章详细讨论。Clojure 使得这些数据结构和原始的数据类型都非常容易使用，可以满足所有的程序的内部数据存储(注：数据在内存中的存在形式)的需要。关于面向对象开发==========================显然的,Clojure 不是 面向对象的。鉴于编程世界被面向对象范式和面向对象语言所统治。因此很多程序员不知道如何采用其他范式（非面向对象）进行编程。 但是Clojure 拒绝了面向对象的哲学（编程范式）不仅不是缺点，还可能使它具有非常强大的力量，提供利用复杂功能的手段，同时保持了代码的简单。在过去的十年,面向对象编程风格通过承诺数据抽象、封装和模块化和代码重用统治了计算机编程领域。它在不同程度上实现了前面的这些承诺，与先前的结构化编程风格相比，面向对象编程方式确实是一种改进。 但是一些问题也显现出来了：   * 一个对象内部的可变状态是很难处理的,在高并发情况下是非常威胁的.   * 实际上并没有真正解决代码抽象和模块化问题. 使用面向对象语言写代码只不过比完全依赖像     "面条"一样的代码的结构化编程风格容易一些而已.   * 继承机制是非常脆弱的,甚至是危险的.所以越来越多的专家,甚至是面向对象语言的专家,都尽量     避免使用继承机制.   * 它鼓励高度的形式化(high degree of ceremony) 和 代码的膨胀. 在Java中的一些简单功能,     也可能需要几个相互依赖的类.通过使用类似 dependency injection 等技术来使用更多不必要     的接口,配置文件和代码生成来实现松耦合.因此程序的大部分代码都不是实际完成工作的代码,而     是为了那些真正工作的代码能正常运行而定义程序结构的代码.Clojure是编程语言的进一步的进化.它建立在面向对象设计模式的优点之上,并且消除了面向对象设计模式中可能导致问题的和不合理的那些特性.实际上 面向对象 这个概念并没有被很好的定义.虽然通常被认为是一个单一的范式,面向对象风格使用一个单一的概念--类,来涵盖各种实际情况、各种特性。而Clojure将这些希望实现的功能进行分离，将它们以独立（不依赖的）、更简单的和更强大的特性分别提供，允许开发人员在特定的情况下独立使用这些相互独立的功能和特性。    * 模块化 类和包提供了将一组相互依存的代码进行集合在一起的方式。Clojure是通过其 名称空i      间机制来实现这一功能的。    * 多态性 继承和接口实现允许通用的代码处理不同类型的对象，甚至不需要实现知道对象的类型      或所有可能的类型都可以适用。 Clojure 的 multimethodes 提供了这种功能，它不仅可以用在      需要处理不同类型的代码中，对那些需要处理任意属性的代码也是适用的。    * 封装 类可以使用一个共同的节目去隐藏背后的那些实现的细节。正如前面讨论的，这个概念依      然具有生命力，这在Clojure中也存在－－函数，不要从函数完成了什么任务这一角度来理解函      数,要用"它接受什么参数,返回什么结果"这样的方式来理解函数.    * 代码重用 在理论上,类可以在不同的环境中,像转头一样构建起更大的项目.虽然这通常是不太      可能完全实现的,但是"代码重用" 仍然是一个有价值的目标. Clojure也遵循了这种模块化重用      的目标,但是通过的是组合的方式,而不是类的方式.与类不同的是,纯函数是不会产生副作用的,      而副作用恰恰是阻碍代码重用的一个很大障碍.Clojure 与其他面向对象编程语言不同的一个主要理念上的不同是：面对对象语言把数据和行为封装在一个类中，甚至在某些情况下模糊数据和行为之间的界限。属性和方法分布在整个代码中，而且相互依存，密不可分。Clojure努力将数据和代码进行分离。Clojure的官网引用了 Alan Perlis说的一句话：“用100个函数操作一个数据比10个数据拥有10个函数要好。”Clojure 尽量避免数据和代码的相互依存，通过提供一个庞大的函数库来操作简单、基础的数据类型。 这是非常重要的，一个Clojure程序强调的不是数据类和结构，而是作用在它们上面的函数式代码。Clojure程序的结构============================一个面向对象式程序通常包含一组类定义，每个类中都包含一些状态，一些对象，和一些对其他类的引用。程序的样子就像下面的图所示的：.. image:: figure1.6.png   :width: 75%一个Clojure程序，最好将它们当作一组函数的集合（作为一个函数式语言）。要从函数到函数的流程和关注代码涉及到的状态的limited points 去理解它们，而不能基于数据或者对象之间的关系去理解它们。Clojure程序看起来像是下面这个样子：.. image:: figure1.7.png   :width: 75%值得注意的是，在一些领域内，例如仿真，面向对象的方式的应用是非常自然的。Clojure理解这些，这就是为什么Clojure最为一门程序语言，更强调的是它的灵活性和扩展性，而不是一味对某种哲学的强调和坚持。因此，利用Clojure的灵活性和强大性去创建一种自定义的面向对象的解决方法去适应问题的做法也就不足为奇了。利用Clojure的宏和元编程机制（metaprogramming facilities）去建立一个对象系统，完全使用Clojure，在适当的时候使用它是完全可能的。Common Lisp有类似的东西：CLOS,Common Lisp Object System，它完全是利用lisp建立的，基于lisp基础宏（top of lisp macros）上的。因此Clojure的用户没有理由不可以作同样的事情；事实上，已经有几个新鲜出炉的Clojure社区项目正在试图提供这样的功能。一个重要的事实是，Clojure可以将你在自己的项目中使用特定的风格和结构的限制中解放出来。面向对象系统是非常强大的，但是它只是一个工具，只有大多数编程语言提供的用来抽象和重用的一种机制而已。Clojure提供给你更多的工具用来抽象和重用－－当这些都有存在必要的时候，它还提供给你建立这些工具的能力。状态管理===============几乎所有的程序都需要管理维护某种类型的工作状态。时不时的，总有程序需要将事实和数据进行储存、更新和进行其他操作。传统上，编程语言处理这些问题是通过允许程序指令直接访问内存在不同层级的抽象来实现的。无论是像c语言和汇编这类低级语言直接操作RAM中的字节，还是像Java和Microsoft的.Net框架提供的垃圾回收机制，大多数程序语言都内置了直接修改共享内存工具的类似概念。在这种范式中，确保状态的处理和访问的合理性，保证不出现问题都完全是程序员的责任。这是非常难以做到的，即使是在最简单的情况下，可变状态的大量使用造成的严重结果是--程序的任何一部分都可以改变状态，所以很难了解到到底发生了什么。Clojure的发明者，Rich Hickey 将充满可变的状态的对象称为“新一代面条代码”。不幸的是，随着多线程在程序中的使用，状态管理的难度成倍的增加。一个程序员不仅要了解所有可能的状态，还要保证状态被保护下有序的修改，以防止数据破坏和冲突条件。这反过来要求复杂的锁规则--强制不能执行。 不遵守这些规则，可能不会产生明显的错误，但是潜在的问题和bug知道在实际的生产环境中才会出现，而且这些错误几乎是无法追踪的。总的来说,使用传统的语言来建立并发程序需要细致周到的规划,对于执行的路径和程序的结构必须有非常透彻的把握,兵器在实施的时候格外的小心.Clojure提供了另外一种替代方法:一种快速，简便的方法，可以为程序员提供尽可能多的状态，因为不需要程序员花额外的的努力来管理这些状态，即使是在高并发的设置中。通过Clojure特有的状态和标识（identity）理念，它的不可变对象和"software transactional memory" (STM) 来完成前面描述的这些目标.状态和标识==================为了理解Clojure中如何处理状态,回到更到的理念的角度来看来认识这个问题是有帮助的.准确的来说,"状态" 和 "改变" 的属于,直指在程序运行中的上下文环境中的概念.传统上,程序员口中的"改变" 指的是下面这种情况,我们把一个给定的对象或者数据结构称为 O,它在值在特定时间T1--区别与之后的时间T2. 不管我们什么时候查看,不管是T1还是T2,O仍然是O。但是，O中的某些属性或者值被改变了，这取决于你存取它们的时间。传统的并发程序使用锁和信号标记（semaphores）来确保不同的线程查询和更新 O的属性或值的行为是有序的，而不会导致问题发生。Clojure提供了不同的观点。在Clojure的世界中，O在T1时和O在T2时并不是同等的概念（不是相同的），而是两个不同的: O1和O2.它们既可以拥有相似的属性或值，也可以没有相似的属性和值，但是关键是 **它们不同的系统对象** .而且遵循严格函数式语言，它们是不可改变的。如果，一个额外的"改变" 发生在O2上，那改变的结果不是被追加到O2的属性或值上，而是创造了一个完全新的对象 O3.一个对象自身是永远不会改变的。为了正确理解上面的内容，看下下面这个例子。 在所有的编程语言中（大多数情况下）数字3就是数字3，而不是其他数字。如果我增加3，就得到新数字4。我并没有改变3的值，而只是改变被某个变量或存储寄存器所容纳的值。"将3改变为不是3"的概念显然是荒唐的，是难以理解其真实意义的，如果我们放任不管，那其余依赖于 "3的值就是3本身"  的程序代码将被殃及。Clojure 将上面阐述的这个关于值的直观概念衍生到其他更复杂的复合值（composite value 译者注：这里的复合值指的是由基本基础数据类型构成的带有结构的值，例如list等）。例如一个名为"欠我钱的人" 的集合。初始化为S1={Joe,Steve,Sarah} .但是后来我收到来自Steve的一封信，信中附带了一张支票。他用这张支票把欠我的钱还清了。"欠我钱的人"这个集合现在就是S2={Joe,Sarah}这两个集合从集合概念的定义上来判断，肯定不是同一个集合：一个包含了Steve，而另一不包含Steve。S1不等于S2的道理，就像3不等4一样。大多数编程语言处理上面的问题，会采用改变集合S值的方式。在并发环境下，这会导致一系列的问题。如果一个线程对集合S进行迭代，当Steve被移除后，它将不可避免的抛出一个错误，可能是类似于"Index out fo bounds" 这类错误。要弥补这一问题，程序员必须手动添加 锁系统 来确保迭代和更新操作是按照一定顺序进行的，而不是在同一时间内进行，即便这两个操作是在不同的线程中发生。Clojure有不同的理念。它解决这类问题的方法不是通过对S存取操作顺序的严格限制来实现的（锁机制）--这种做法只是对真正问题的一种临行性补救措施，而不是解决问题的真正方法。真正概念上的问题是，在遍历集合S的某一时刻，程序默认{Joe,Sarah}={Joe,Steve,Sarah} .这显然不是真实的情况，而就是这个脱节（程序的默认情况与实际情况不一致）导致了一系列的问题。在通常情况下，我们期望一个对象是和它本身相等的，但是在并发系统中的情况不是这样的。通过使用不可变对象，Clojure保证了一个对象总是和自己相等的假设。在Clojure系统中，S1和S2对于程序来讲总是不同的，就像它们在语义上和概念上的不同一样。对S1产生的作用，对S2没有任何影响，所以程序可以顺利结束，不会发生错误。显然集合S1和S2之间还是存在某些联系的。从人类的视角来看，这两个集合都代表了同一个概念："欠我钱的人的一个集合". Clojure通过引入一个叫标识符（identity）的概念来记录这种因为值不同而带来的差异。标识符在Clojure中是一个被命名的引用，它指向一个对象（类似指针）。在上面的例子中，可能只有一个标识符，用 debtors 举例来说。在某一时刻，debtors 这个标识符指向的是S1这个集合对象，而在另一个时刻，debtors这个标识符转而指向S2这个集合对象。这种改变是原子性的，因此可以避免对并发产生类似冲突条件等影响。debtors 这个标识符在某一时刻的状态值并不重要，它不是指向S1就是S2，而不会指向其他的什么。所以取回当前debtors的值总是安全的，在debtors更新了指向的对象后也是安全的。.. image:: figure1.8.png   :width: 75%Software Transactional Memory==================================恰当的来说，状态 和 标识符 不是解决这一问题的完全答案。经常的情况是，在程序中改变一个标识符取决于另一个状态值或者获得一个标识符的新值需要基于对一个现有的值的计算结构,而这些情况下都没有考虑到在进行上述操作的时候可能有其他线程对标识符进行的更新.这不会像我们之前讨论的发生错误,但是可能导致一个返回的值被不适当的覆盖.为了应对这些问题,Clojure提供了一个 software transactional memory (STM)的机制.STM 在程序和计算机内存之间增加了额外的一个管理层.当一个程序需要协调,改变一个或者更多标识符的时候,它(STM)会将这些封装为一个事务(将多个相关的操作,作为一个整体的单位),这非常类似于SQL数据库管理中保证数据完整性的措施.在一个事务中,程序员可以执行多个基于标识符的计算,赋给它们新的值,然后将这些提交更新. 从程序的其他部分来看,事务是即时性的和原子性的: 首先标识符拥有一个值,然后拥有另一个值,而不需要担心存在中间状态和不一致的数据出现.如果存在两个冲突的事务,其中的一个将被迫重新尝试,开启一个新的标识符来进行尝试. 这些都是自动发生的;程序只需要编写代码,事务逻辑机制将自动使用STM引擎来处理.   Clojure对下面下列内容进行了保证. 事务总是:    * 原子的 在一个事务中,所有的改变要么都发生,要么都不发生.程序中绝对不会出现一些改变      被提交,而另外一些没有被提交. 这为避免从破坏了的数据创建一种不一致的状态提供了保证.    * 一致性 事务在被提交前可以进行验证. Clojure提供了非常容易的机制,通过 增加运行时      测试保证修改的新值是你希望的,这样就保证了将新值指派给标识符不会发生问题.    * 隔离性 没有一个事务在运行中可以"看到" 另一个事务中的效果.在一个事务开始时,程序      对所有的设计的标识符建立一个"快照" , 对标识符的操作实际上是作用在这些快照上的。      这就保证了一个事务中的代码可以任意修改，而不需要担心标识符可能已经被改变（因为被操      作的是标识符的快照），这样我们就为执行代码扫清了障碍。这个系统保证了不会发生阻塞，也不会产生死锁，读取操作总是立即执行，返回一个当前标识符的值。因为在STM系统中储存的对象是不可变更的，读操作永远不会阻塞写操作。如果读操作读取的部分的状态在之后被修改，从读操作返回的对象不会（也不可能）被改变，所以任意代码都可以继续正确使用它。但是如果下一次对标识符的读取操作是在另一个事务中，或者不在任何事务中时，它（标识符）当然的会返回新的值。当一个写事务在其他事务之前完成了，因而产生的冲突将由STM来管理。如果这两个更新是属于两个独立不同的标识符时，那么这两个更新都会被立即提交，不会发生任何问题，也不需要额外的等待。但是，如果这两个更新事务冲突，那它们将由STM系统来指定优先级别，然后其中一个事务将被要求重启或者重试。这一切都是自动发生的，不需要程序开发者进行额外的处理。Clojure 还提供了一个有偿的操作－－一个指定的写操作可以在相关的事务中的任何时候被执行而不用顾及顺序。这个有偿的操作不会被阻塞和重试。因此我们得出的结论是，导致一个程序不能按部就班执行下去的情况只有一个，就是当两个写入操作发生冲突的时候。但是不管什么情况，在STM的管理下，数据的完整性得到了保证－－冲突的两个事务中会有一个被要求从头开始执行。即使在高并发的情况下，STM系统仍然可以安排好事务之间的顺序并确保高效的执行。*******************************STM 和性能**毫无疑问，一些读者会担心在程序和内存之间的这个附加的管理层（STM)会影响程序的性能。对这个担忧的回答是：有些影响，但是非常轻微。因为Clojure中的数据结构是不可变的，读操作几乎是没有那些额外的开销的－－它可以简单的将当前的值取出，而不需要关心锁和同步的问题。同样，毫无疑问的写入操作也是非常迅速的，只需要STM付出少量的开销。在高并发写入的情况下，Clojure的STM可能比良好设计的（定制化、细粒度）锁机制要慢。这是STM一个无法避免的缺点：管理事务提交和重试这些任务总会增加一些开销，针对某一并发情况而定制的解决方案必然比作为通用管理方式的STM要有性能上的优势。Clojure采取的策略是，这些轻微的、可能的开销和随之带来的程序的可读性和概念上的清晰的优势相比是微不足道的。一个高效的、细粒度的锁系统是非常难以设计的，而在Clojure的实现中，可以不用考虑这些并发问题。一个有趣的类比是将STM（管理状态）和其他环境中的垃圾回收（管理内存）进行对比。它们要面对很多相似的问题：人工编写的，底层的代码可能更有效率，但是允许运行时系统管理更多的事情，程序员的生活可以更美好。而且随着技术的进步，垃圾回收器的性能得到很大提升，和用手写的优化代码的差距缩短到几纳秒的差距，在这种情况下，手写的优化代码没有太大的必要性了。这种事情同样可以用来解释STM，STM作为一个工具，可以让程序员处理高层次的问题，而不是纠结于底层细节，它让程序员的工作更加简便。针对STM的研究和优化还在不断进行中，所以可以预料STM的性能会不断提高，而且这种提高会不断整合到Clojure中来。*****************************----------------------总结----------------------这一章包含了很多内容,本书剩余的部分会对这些内容进行展开,进行详细的说明,解释它们如何被运用到真实的编程环境中.但是本章讲述的内容,是Clojure的灵魂.理解Clojure是一门高度动态化、元编程式的lisp的方言将可以让你能够充分发挥Clojure的优势，使用强大的抽象，可以避免裁减和编写冗余代码的苦差事。了解Clojure是一门函数式语言，鼓励在可能的情况下尽量使用纯函数式的编程风格将会帮助你构建更简单的，更优雅的程序流程结构。牢记这些将帮助你把任务分解为离散的、小单位的代码，和协调在函数流程结构之间的数据。你很快就会喜欢上这些不可变的数据结构，以及它们总是可以被安全的使用带来的自由和便利。最重要的是，Clojure和永久性数据结构特殊关系将允许你编写健壮，可伸缩的应用程序。数据结构的更新和管理都变得简单，允许你将精力放在处理事情的真正代码上，享受编写代码的乐趣。